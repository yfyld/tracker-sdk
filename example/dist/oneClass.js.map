{"version":3,"file":"oneClass.js","sources":["../../dist/telescope.min.js","../src/oneClass.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = global || self, factory(global.Telescope = {}));\n}(this, function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    //日志收集接口\r\n    var SERVER_URL = (window.location.protocol === 'https:' ? 'https:' : 'http:') + \"//frontlo-collection.91jkys.com/log.gif\"; //'http://test.qa.91jkys.com:9342/log.gif';\r\n    var CUSTOM_TOKEN_KEY = 'TRACKER_IDENTIFY';\r\n    var SEND_TYPE = {\r\n        SYNC: 'SYNC',\r\n        ASYNC: 'ASYNC',\r\n        UNLOAD: 'UNLOAD'\r\n    };\r\n    var ACTION_TYPE = {\r\n        EVENT: 'EVENT',\r\n        PAGE: 'PAGE',\r\n        VIEW: 'VIEW',\r\n        DURATION: 'DURATION'\r\n    };\r\n    var SAFETY_KEY = [\r\n        'custom',\r\n        'actionType',\r\n        'eventName',\r\n        'pageId',\r\n        'domId',\r\n        'domClass',\r\n        'domHref',\r\n        'domName',\r\n        'domTag',\r\n        'domContent',\r\n        'domPath',\r\n        'trackId',\r\n        'referrerId',\r\n        'score',\r\n        'startTime',\r\n        'endTime',\r\n        'durationTime',\r\n        'channel',\r\n        'netType'\r\n    ];\n\n    //default config\r\n    var config = {\r\n        store: 'test',\r\n        trackKey: '',\r\n        serverUrl: SERVER_URL,\r\n        pageTime: true,\r\n        watchHistoryAndHash: true,\r\n        env: 'PRODUCT',\r\n        console: true,\r\n        projectId: null,\r\n        version: null,\r\n        domain: '',\r\n        sendType: SEND_TYPE.ASYNC,\r\n        delayTime: 1000,\r\n        autoTrackPage: false,\r\n        autoTrackClick: false,\r\n        autoInstall: true,\r\n        delayLink: true,\r\n        delayLinkTime: 200,\r\n        useServerTime: true,\r\n        corssSubdomain: false,\r\n        utokenKey: CUSTOM_TOKEN_KEY,\r\n        beforeGenerateLog: null\r\n    };\r\n    //script tracker-key  config\r\n    var scriptDom = document.querySelector('script[track-key]');\r\n    if (scriptDom) {\r\n        var trackKey = scriptDom.getAttribute('track-key') || '';\r\n        if (trackKey) {\r\n            config.trackKey = trackKey;\r\n        }\r\n    }\r\n    function getConfig() {\r\n        return config;\r\n    }\r\n    function setConfig(data) {\r\n        config = __assign(__assign({}, config), data);\r\n    }\n\n    function _isPlaceholder(a) {\n      return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n    }\n\n    var _isPlaceholder_1 = _isPlaceholder;\n\n    /**\n     * Optimized internal one-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n\n    function _curry1(fn) {\n      return function f1(a) {\n        if (arguments.length === 0 || _isPlaceholder_1(a)) {\n          return f1;\n        } else {\n          return fn.apply(this, arguments);\n        }\n      };\n    }\n\n    var _curry1_1 = _curry1;\n\n    /**\n     * Optimized internal two-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n\n    function _curry2(fn) {\n      return function f2(a, b) {\n        switch (arguments.length) {\n          case 0:\n            return f2;\n\n          case 1:\n            return _isPlaceholder_1(a) ? f2 : _curry1_1(function (_b) {\n              return fn(a, _b);\n            });\n\n          default:\n            return _isPlaceholder_1(a) && _isPlaceholder_1(b) ? f2 : _isPlaceholder_1(a) ? _curry1_1(function (_a) {\n              return fn(_a, b);\n            }) : _isPlaceholder_1(b) ? _curry1_1(function (_b) {\n              return fn(a, _b);\n            }) : fn(a, b);\n        }\n      };\n    }\n\n    var _curry2_1 = _curry2;\n\n    function _arrayFromIterator(iter) {\n      var list = [];\n      var next;\n\n      while (!(next = iter.next()).done) {\n        list.push(next.value);\n      }\n\n      return list;\n    }\n\n    var _arrayFromIterator_1 = _arrayFromIterator;\n\n    function _includesWith(pred, x, list) {\n      var idx = 0;\n      var len = list.length;\n\n      while (idx < len) {\n        if (pred(x, list[idx])) {\n          return true;\n        }\n\n        idx += 1;\n      }\n\n      return false;\n    }\n\n    var _includesWith_1 = _includesWith;\n\n    function _functionName(f) {\n      // String(x => x) evaluates to \"x => x\", so the pattern may not match.\n      var match = String(f).match(/^function (\\w*)/);\n      return match == null ? '' : match[1];\n    }\n\n    var _functionName_1 = _functionName;\n\n    function _has(prop, obj) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    var _has_1 = _has;\n\n    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    function _objectIs(a, b) {\n      // SameValue algorithm\n      if (a === b) {\n        // Steps 1-5, 7-10\n        // Steps 6.b-6.e: +0 != -0\n        return a !== 0 || 1 / a === 1 / b;\n      } else {\n        // Step 6.a: NaN == NaN\n        return a !== a && b !== b;\n      }\n    }\n\n    var _objectIs_1 = typeof Object.is === 'function' ? Object.is : _objectIs;\n\n    var toString = Object.prototype.toString;\n\n    var _isArguments =\n    /*#__PURE__*/\n    function () {\n      return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n        return toString.call(x) === '[object Arguments]';\n      } : function _isArguments(x) {\n        return _has_1('callee', x);\n      };\n    }();\n\n    var _isArguments_1 = _isArguments;\n\n    // cover IE < 9 keys issues\n\n\n    var hasEnumBug = !\n    /*#__PURE__*/\n    {\n      toString: null\n    }.propertyIsEnumerable('toString');\n    var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug\n\n    var hasArgsEnumBug =\n    /*#__PURE__*/\n    function () {\n\n      return arguments.propertyIsEnumerable('length');\n    }();\n\n    var contains = function contains(list, item) {\n      var idx = 0;\n\n      while (idx < list.length) {\n        if (list[idx] === item) {\n          return true;\n        }\n\n        idx += 1;\n      }\n\n      return false;\n    };\n    /**\n     * Returns a list containing the names of all the enumerable own properties of\n     * the supplied object.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own properties.\n     * @see R.keysIn, R.values\n     * @example\n     *\n     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n     */\n\n\n    var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?\n    /*#__PURE__*/\n    _curry1_1(function keys(obj) {\n      return Object(obj) !== obj ? [] : Object.keys(obj);\n    }) :\n    /*#__PURE__*/\n    _curry1_1(function keys(obj) {\n      if (Object(obj) !== obj) {\n        return [];\n      }\n\n      var prop, nIdx;\n      var ks = [];\n\n      var checkArgsLength = hasArgsEnumBug && _isArguments_1(obj);\n\n      for (prop in obj) {\n        if (_has_1(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n          ks[ks.length] = prop;\n        }\n      }\n\n      if (hasEnumBug) {\n        nIdx = nonEnumerableProps.length - 1;\n\n        while (nIdx >= 0) {\n          prop = nonEnumerableProps[nIdx];\n\n          if (_has_1(prop, obj) && !contains(ks, prop)) {\n            ks[ks.length] = prop;\n          }\n\n          nIdx -= 1;\n        }\n      }\n\n      return ks;\n    });\n    var keys_1 = keys;\n\n    /**\n     * Gives a single-word string description of the (native) type of a value,\n     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n     * attempt to distinguish user Object types any further, reporting them all as\n     * 'Object'.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Type\n     * @sig (* -> {*}) -> String\n     * @param {*} val The value to test\n     * @return {String}\n     * @example\n     *\n     *      R.type({}); //=> \"Object\"\n     *      R.type(1); //=> \"Number\"\n     *      R.type(false); //=> \"Boolean\"\n     *      R.type('s'); //=> \"String\"\n     *      R.type(null); //=> \"Null\"\n     *      R.type([]); //=> \"Array\"\n     *      R.type(/[A-z]/); //=> \"RegExp\"\n     *      R.type(() => {}); //=> \"Function\"\n     *      R.type(undefined); //=> \"Undefined\"\n     */\n\n\n    var type =\n    /*#__PURE__*/\n    _curry1_1(function type(val) {\n      return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n    });\n\n    var type_1 = type;\n\n    /**\n     * private _uniqContentEquals function.\n     * That function is checking equality of 2 iterator contents with 2 assumptions\n     * - iterators lengths are the same\n     * - iterators values are unique\n     *\n     * false-positive result will be returned for comparision of, e.g.\n     * - [1,2,3] and [1,2,3,4]\n     * - [1,1,1] and [1,2,3]\n     * */\n\n\n    function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {\n      var a = _arrayFromIterator_1(aIterator);\n\n      var b = _arrayFromIterator_1(bIterator);\n\n      function eq(_a, _b) {\n        return _equals(_a, _b, stackA.slice(), stackB.slice());\n      } // if *a* array contains any element that is not included in *b*\n\n\n      return !_includesWith_1(function (b, aItem) {\n        return !_includesWith_1(eq, aItem, b);\n      }, b, a);\n    }\n\n    function _equals(a, b, stackA, stackB) {\n      if (_objectIs_1(a, b)) {\n        return true;\n      }\n\n      var typeA = type_1(a);\n\n      if (typeA !== type_1(b)) {\n        return false;\n      }\n\n      if (a == null || b == null) {\n        return false;\n      }\n\n      if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {\n        return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);\n      }\n\n      if (typeof a.equals === 'function' || typeof b.equals === 'function') {\n        return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);\n      }\n\n      switch (typeA) {\n        case 'Arguments':\n        case 'Array':\n        case 'Object':\n          if (typeof a.constructor === 'function' && _functionName_1(a.constructor) === 'Promise') {\n            return a === b;\n          }\n\n          break;\n\n        case 'Boolean':\n        case 'Number':\n        case 'String':\n          if (!(typeof a === typeof b && _objectIs_1(a.valueOf(), b.valueOf()))) {\n            return false;\n          }\n\n          break;\n\n        case 'Date':\n          if (!_objectIs_1(a.valueOf(), b.valueOf())) {\n            return false;\n          }\n\n          break;\n\n        case 'Error':\n          return a.name === b.name && a.message === b.message;\n\n        case 'RegExp':\n          if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {\n            return false;\n          }\n\n          break;\n      }\n\n      var idx = stackA.length - 1;\n\n      while (idx >= 0) {\n        if (stackA[idx] === a) {\n          return stackB[idx] === b;\n        }\n\n        idx -= 1;\n      }\n\n      switch (typeA) {\n        case 'Map':\n          if (a.size !== b.size) {\n            return false;\n          }\n\n          return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));\n\n        case 'Set':\n          if (a.size !== b.size) {\n            return false;\n          }\n\n          return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));\n\n        case 'Arguments':\n        case 'Array':\n        case 'Object':\n        case 'Boolean':\n        case 'Number':\n        case 'String':\n        case 'Date':\n        case 'Error':\n        case 'RegExp':\n        case 'Int8Array':\n        case 'Uint8Array':\n        case 'Uint8ClampedArray':\n        case 'Int16Array':\n        case 'Uint16Array':\n        case 'Int32Array':\n        case 'Uint32Array':\n        case 'Float32Array':\n        case 'Float64Array':\n        case 'ArrayBuffer':\n          break;\n\n        default:\n          // Values of other types are only equal if identical.\n          return false;\n      }\n\n      var keysA = keys_1(a);\n\n      if (keysA.length !== keys_1(b).length) {\n        return false;\n      }\n\n      var extendedStackA = stackA.concat([a]);\n      var extendedStackB = stackB.concat([b]);\n      idx = keysA.length - 1;\n\n      while (idx >= 0) {\n        var key = keysA[idx];\n\n        if (!(_has_1(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {\n          return false;\n        }\n\n        idx -= 1;\n      }\n\n      return true;\n    }\n\n    var _equals_1 = _equals;\n\n    /**\n     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles\n     * cyclical data structures.\n     *\n     * Dispatches symmetrically to the `equals` methods of both arguments, if\n     * present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Relation\n     * @sig a -> b -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      R.equals(1, 1); //=> true\n     *      R.equals(1, '1'); //=> false\n     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true\n     *\n     *      const a = {}; a.v = a;\n     *      const b = {}; b.v = b;\n     *      R.equals(a, b); //=> true\n     */\n\n\n    var equals =\n    /*#__PURE__*/\n    _curry2_1(function equals(a, b) {\n      return _equals_1(a, b, [], []);\n    });\n\n    var equals_1 = equals;\n\n    /**\r\n     *判断promise\r\n     *\r\n     * @export\r\n     * @param {*} f\r\n     * @returns\r\n     */\r\n    function isThenable(f) {\r\n        return f && typeof f.then === 'function';\r\n    }\r\n    /**\r\n     *获取url参数 兼容微信支付 window.location.search改成window.location.href\r\n     *\r\n     * @export\r\n     * @param {string} variable\r\n     * @returns\r\n     */\r\n    function getQueryVariable(variable) {\r\n        var query = window.location.href.match(/\\?(.*)$/);\r\n        if (!query)\r\n            return null;\r\n        var vars = query[1].split('&');\r\n        for (var i = 0; i < vars.length; i++) {\r\n            var pair = vars[i].split('=');\r\n            if (pair[0] == variable) {\r\n                return pair[1];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *获取cookie\r\n     *\r\n     * @export\r\n     * @param {string} name\r\n     * @returns\r\n     */\r\n    function getCookie(name) {\r\n        var cookies = document.cookie.split('; ');\r\n        for (var i in cookies) {\r\n            var arr = cookies[i].split('=');\r\n            if (name == arr[0]) {\r\n                return unescape(arr[1]).replace(/&&&&/g, ';');\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *设置cookie\r\n     *\r\n     * @export\r\n     * @param {string} name\r\n     * @param {string} value\r\n     * @param {number} [expires=99999999999999]\r\n     * @param {string} [path='/']\r\n     * @param {string} [domain]\r\n     */\r\n    function setCookie(name, value, expires, path, domain) {\r\n        if (expires === void 0) { expires = 99999999999999; }\r\n        if (path === void 0) { path = '/'; }\r\n        document.cookie =\r\n            name +\r\n                '=' +\r\n                value.replace(/;/g, '&&&&') +\r\n                (expires ? '; expires=' + getExpires(expires) : '') +\r\n                (path ? '; path=' + path : '') +\r\n                (domain ? '; domain=' + domain : '');\r\n        function getExpires(hours) {\r\n            var date = new Date();\r\n            date.setTime(date.getTime() + hours * 60 * 60 * 1000);\r\n            return date.toUTCString();\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     *\r\n     * @export\r\n     * @param {*} binding\r\n     * @returns\r\n     */\r\n    function notChanged(binding) {\r\n        if (binding.oldValue !== undefined) {\r\n            if (typeof binding.value === 'object') {\r\n                return equals_1(binding.value, binding.oldValue);\r\n            }\r\n            else {\r\n                return binding.value === binding.oldValue;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * if the binding value is empty\r\n     */\r\n    function isEmpty(binding) {\r\n        return binding.value === '' || binding.value === undefined || binding.value === null;\r\n    }\r\n    function setFlag(key, value) {\r\n        if (value === void 0) { value = true; }\r\n        _TrackerGlobalData._trackerFlag = _TrackerGlobalData._trackerFlag || {};\r\n        _TrackerGlobalData._trackerFlag[key] = value;\r\n    }\r\n    function getFlag(key) {\r\n        _TrackerGlobalData._trackerFlag = _TrackerGlobalData._trackerFlag || {};\r\n        return _TrackerGlobalData._trackerFlag[key] || false;\r\n    }\r\n    function getUUID() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\r\n            return v.toString(16);\r\n        });\r\n    }\r\n    /**\r\n     *获取dom path\r\n     *\r\n     * @export\r\n     * @param {HTMLElement} dom\r\n     * @returns\r\n     */\r\n    function getDomPath(dom) {\r\n        var path = [dom.id ? '#' + dom.id : dom.tagName.toLowerCase()];\r\n        while (dom.parentNode && dom.parentNode.tagName !== 'BODY') {\r\n            dom = dom.parentNode;\r\n            path.unshift(dom.id ? '#' + dom.id : dom.tagName.toLowerCase());\r\n        }\r\n        return path.join('>');\r\n    }\r\n    function getLocationHref() {\r\n        if (typeof document === 'undefined' || document.location == null)\r\n            return '';\r\n        return document.location.href;\r\n    }\r\n    function isObject(o) {\r\n        return Object.prototype.toString.call(o) === '[object Object]';\r\n    }\n\n    var userInfo = {\r\n        uid: null,\r\n        isLogin: false\r\n    };\r\n    function setUserInfo(info) {\r\n        userInfo = __assign(__assign({}, userInfo), info);\r\n    }\r\n    function getUserInfo() {\r\n        return userInfo;\r\n    }\r\n    function login(info) {\r\n        var config = getConfig();\r\n        if (info.uid) {\r\n            var utoken = localStorage.getItem(config.utokenKey + '__' + info.uid);\r\n            if (utoken) {\r\n                setCookie(config.utokenKey, utoken);\r\n            }\r\n        }\r\n        setUserInfo(__assign(__assign({}, info), { isLogin: true }));\r\n    }\r\n    function logout(moment) {\r\n        if (moment === void 0) { moment = false; }\r\n        var config = getConfig();\r\n        var utoken = getCookie(config.utokenKey);\r\n        if (moment) {\r\n            localStorage.setItem(config.utokenKey + '__' + (userInfo.uid || ''), utoken);\r\n            setCookie(config.utokenKey, null);\r\n        }\r\n        userInfo = { uid: null, isLogin: false };\r\n    }\n\n    // import { login } from './core/user';\r\n    var ua = window.navigator.userAgent;\r\n    if (/(pre|qa|127|192)\\.|localhost/.test(window.location.host) || /env\\((pre|qa)\\)/.test(ua)) {\r\n        setConfig({\r\n            serverUrl: (window.location.protocol === 'http:' ? 'http:' : 'https:') + \"//frontlo-collection.qa.91jkys.com/log.gif\"\r\n        });\r\n    }\r\n    if (/DeviceId/.test(ua)) {\r\n        var deviceIdMatch = ua.match(/DeviceId\\((.*?)\\)/);\r\n        if (deviceIdMatch && deviceIdMatch.length >= 2) {\r\n            setUserInfo({\r\n                utoken: deviceIdMatch[1]\r\n            });\r\n        }\r\n    }\r\n    // if (typeof Sailer !== 'undefined' && typeof adapt !== 'undefined') {\r\n    //   if (adapt.isLogin()) {\r\n    //     adapt.getUserInfo().then(({ uid }: any) => {\r\n    //       login(uid);\r\n    //     });\r\n    //   }\r\n    // }\n\n    var pageInfo = {\r\n        pageId: null,\r\n        referrerId: getQueryVariable('referrer-id'),\r\n        referrerUrl: document.referrer || '',\r\n        url: location.origin,\r\n        host: location.host,\r\n        path: location.pathname,\r\n        hash: location.hash,\r\n        title: document.title || ''\r\n    };\r\n    var setPageInfo = function (info) {\r\n        pageInfo = __assign(__assign(__assign({}, pageInfo), info), { url: location.origin, host: location.host, path: location.pathname, hash: location.hash, title: document.title || '' });\r\n        window.aaa = pageInfo;\r\n    };\r\n    var getPageInfo = function () {\r\n        return __assign({}, pageInfo);\r\n    };\n\n    function http(data, isAjax, isSendBeacon) {\r\n        if (isAjax === void 0) { isAjax = false; }\r\n        if (isSendBeacon === void 0) { isSendBeacon = true; }\r\n        return new Promise(function (resolve) {\r\n            //const dataStr=Base64.encode(JSON.stringify(data));\r\n            var dataStr = data;\r\n            var config = getConfig();\r\n            var url = config.serverUrl + \"?\" + (config.trackKey ? \"trackKey=\" + config.trackKey + \"&\" : '') + \"time=\" + Date.now();\r\n            if (window.location.protocol === 'https:' &&\r\n                isSendBeacon &&\r\n                typeof window.navigator.sendBeacon === 'function' &&\r\n                typeof Blob === 'function') {\r\n                var headers = {\r\n                    type: 'text/plain; charset=UTF-8'\r\n                };\r\n                var blob = new Blob([dataStr], headers);\r\n                var success = window.navigator.sendBeacon(url, blob);\r\n                if (success) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n            }\r\n            if (isAjax) {\r\n                var xhr = new XMLHttpRequest();\r\n                xhr.withCredentials = true;\r\n                xhr.addEventListener('readystatechange', function () {\r\n                    if (this.readyState === 4) {\r\n                        resolve();\r\n                    }\r\n                });\r\n                xhr.open('POST', url, true);\r\n                xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');\r\n                xhr.withCredentials = true;\r\n                xhr.send(dataStr);\r\n            }\r\n            else {\r\n                var img = new Image();\r\n                img.onload = function () {\r\n                    resolve();\r\n                };\r\n                img.src = url + \"&data=\" + encodeURIComponent(dataStr);\r\n            }\r\n        });\r\n    }\n\n    var libInfo = {\r\n        libVersion: '1.0.0',\r\n        libType: 'js'\r\n    };\n\n    function getNetInfo () {\r\n        var connection = window.navigator.connection ||\r\n            window.navigator.mozConnection ||\r\n            window.navigator.webkitConnection ||\r\n            {};\r\n        if (connection) {\r\n            return {};\r\n        }\r\n        var type = connection.type || connection.effectiveType;\r\n        if (!type) {\r\n            return {};\r\n        }\r\n        return {\r\n            netType: type\r\n        };\r\n    }\n\n    function clientInfo () {\r\n        return {\r\n            clientWidth: window.screen.height,\r\n            clientHeight: window.screen.width,\r\n            radio: window.devicePixelRatio || 1,\r\n            domain: document.domain || ''\r\n        };\r\n    }\n\n    /**\n     * Returns a partial copy of an object containing only the keys specified. If\n     * the key does not exist, the property is ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @see R.omit, R.props\n     * @example\n     *\n     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n     */\n\n\n    var pick =\n    /*#__PURE__*/\n    _curry2_1(function pick(names, obj) {\n      var result = {};\n      var idx = 0;\n\n      while (idx < names.length) {\n        if (names[idx] in obj) {\n          result[names[idx]] = obj[names[idx]];\n        }\n\n        idx += 1;\n      }\n\n      return result;\n    });\n\n    var pick_1 = pick;\n\n    var allData = [];\r\n    var timer = null;\r\n    var uuid = getUUID();\r\n    var index = 0;\r\n    /**\r\n     * 同步发送\r\n     * @param data\r\n     */\r\n    function send(data) {\r\n        var config = getConfig();\r\n        var sendType = config.sendType;\r\n        if (sendType === SEND_TYPE.SYNC) {\r\n            sendSync(data);\r\n        }\r\n        else if (sendType === SEND_TYPE.ASYNC) {\r\n            sendAsync(data);\r\n        }\r\n    }\r\n    function sendSync(data) {\r\n        var config = getConfig();\r\n        var newData = _generateData(data, config);\r\n        if (!newData) {\r\n            return;\r\n        }\r\n        allData.push(newData);\r\n        clearTimeout(timer);\r\n        _sendToServer(allData);\r\n        allData.length = 0;\r\n    }\r\n    /**\r\n     * 延迟发送  data不存在则马上发送\r\n     * @param data\r\n     */\r\n    function sendAsync(data) {\r\n        var config = getConfig();\r\n        if (data) {\r\n            var newData = _generateData(data, config);\r\n            if (!newData) {\r\n                return;\r\n            }\r\n            allData.push(newData);\r\n        }\r\n        clearTimeout(timer);\r\n        // 无参数或者大于10条发送发送\r\n        if ((!data && allData.length > 0) || allData.length >= 10) {\r\n            _sendToServer(allData);\r\n            allData.length = 0;\r\n            return;\r\n        }\r\n        timer = setTimeout(function () {\r\n            _sendToServer(allData);\r\n            allData.length = 0;\r\n        }, config.delayTime);\r\n    }\r\n    /**\r\n     * 发送到服务器\r\n     * @param data\r\n     * @param isAjax\r\n     */\r\n    function _sendToServer(data, isAjax) {\r\n        // console.log(JSON.stringify(data, null, 2));\r\n        return http(JSON.stringify(_wrapperData(data)), isAjax);\r\n    }\r\n    /**\r\n     * 合并其他信息\r\n     * @param data\r\n     */\r\n    function _wrapperData(data) {\r\n        //console.log(JSON.stringify(data, null, 2));\r\n        var config = getConfig();\r\n        index++;\r\n        return __assign(__assign(__assign(__assign({ items: data }, clientInfo()), libInfo), getUserInfo()), { version: config.version });\r\n    }\r\n    /**\r\n     * 补充埋点信息\r\n     * @param data\r\n     * @param config\r\n     */\r\n    function _generateData(data, config) {\r\n        index++;\r\n        if (typeof config.beforeGenerateLog === 'function') {\r\n            data = config.beforeGenerateLog(data);\r\n            if (!data) {\r\n                return;\r\n            }\r\n        }\r\n        //序列化自定义\r\n        if (isObject(data.custom)) {\r\n            var customStr = JSON.stringify(data.custom);\r\n            if (customStr.length <= 500) {\r\n                data.custom = JSON.stringify(data.custom);\r\n            }\r\n        }\r\n        var newData = pick_1(SAFETY_KEY, data);\r\n        var pageInfo = getPageInfo();\r\n        var netInfo = getNetInfo();\r\n        if (data.actionType === 'PAGE') {\r\n            pageInfo.pageId = null;\r\n        }\r\n        var result = __assign(__assign(__assign(__assign({}, newData), pageInfo), netInfo), { trackTime: Date.now(), id: uuid + '-' + index });\r\n        // console.log(JSON.stringify(result, null, 2));\r\n        return result;\r\n    }\n\n    var PageTimeTracker = /** @class */ (function () {\r\n        function PageTimeTracker() {\r\n            this.startTime = Date.now();\r\n            this.endTime = Date.now();\r\n            // invalidStartTime = Date.now();\r\n            // invalidEndTime = Date.now();\r\n            // totalInvalidTime = 0;\r\n            this.config = null;\r\n            this.info = null;\r\n            this.isStart = false;\r\n            this.backInfo = null;\r\n        }\r\n        PageTimeTracker.getInstance = function () {\r\n            if (!PageTimeTracker.instance) {\r\n                PageTimeTracker.instance = new PageTimeTracker();\r\n            }\r\n            return PageTimeTracker.instance;\r\n        };\r\n        PageTimeTracker.prototype.start = function (data) {\r\n            var _this = this;\r\n            if (data) {\r\n                this.info = data;\r\n            }\r\n            if (this.isStart) {\r\n                this.startTime = Date.now();\r\n                return;\r\n            }\r\n            this.isStart = true;\r\n            this.config = getConfig();\r\n            window.addEventListener('visibilitychange', function () {\r\n                var isHidden = document.hidden;\r\n                if (isHidden) {\r\n                    _this.backInfo = _this.info;\r\n                    _this.end();\r\n                }\r\n                else {\r\n                    _this.info = _this.backInfo;\r\n                    // todo 处理pageInfo\r\n                    _this.start();\r\n                }\r\n            });\r\n        };\r\n        PageTimeTracker.prototype.end = function () {\r\n            if (!this.info) {\r\n                return;\r\n            }\r\n            this.endTime = Date.now();\r\n            this.toSend();\r\n        };\r\n        /**\r\n         * url change 触发\r\n         */\r\n        PageTimeTracker.prototype.change = function () {\r\n            this.end();\r\n            this.start();\r\n        };\r\n        PageTimeTracker.prototype.toSend = function () {\r\n            if (this.config.autoTrackPage || this.info) {\r\n                var durationTime = this.endTime - this.startTime;\r\n                if (durationTime < 100) {\r\n                    // 手动发后100豪秒内不能自动change\r\n                    return;\r\n                }\r\n                var data = __assign(__assign({ startTime: this.startTime, durationTime: durationTime }, this.info), { actionType: ACTION_TYPE.DURATION, trackId: '' });\r\n                send(data);\r\n                this.info = null;\r\n            }\r\n        };\r\n        PageTimeTracker.instance = null;\r\n        return PageTimeTracker;\r\n    }());\r\n    var instance = PageTimeTracker.getInstance();\n\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n    function createCommonjsModule(fn, module) {\n    \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n\n    var vissense = createCommonjsModule(function (module, exports) {\n    /*! { \"name\": \"vissense\", \"version\": \"0.10.0\", \"homepage\": \"https://vissense.github.io/vissense\",\"copyright\": \"(c) 2016 tbk\" } */\n    !function(root, name, factory) {\n        var withWindow = function(win) {\n            var product = factory(win, win.document);\n            return product.noConflict = function() {\n                return product;\n            }, product;\n        };\n        module.exports = function(win) {\n            return withWindow(win);\n        };\n    }(commonjsGlobal, \"VisSense\", function(window, document, undefined$1) {\n        function async(callback, delay) {\n            return function() {\n                var args = arguments;\n                return defer(function() {\n                    callback.apply(undefined$1, args);\n                }, delay || 0);\n            };\n        }\n        function debounce(callback, delay) {\n            var cancel = noop;\n            return function() {\n                var self = this, args = arguments;\n                cancel(), cancel = defer(function() {\n                    callback.apply(self, args);\n                }, delay);\n            };\n        }\n        function defaults(dest, source) {\n            var sourceIsObject = isObject(source), destIsObject = isObject(dest);\n            return sourceIsObject || destIsObject ? sourceIsObject && destIsObject ? (forEach(Object.keys(source), function(property) {\n                dest[property] === undefined$1 && (dest[property] = source[property]);\n            }), dest) : sourceIsObject ? source : dest : source;\n        }\n        function defer(callback, delay) {\n            var timer = setTimeout(function() {\n                callback();\n            }, delay || 0);\n            return function() {\n                clearTimeout(timer);\n            };\n        }\n        function fireIf(when, callback) {\n            return function() {\n                return (isFunction(when) ? when() : when) ? callback() : undefined$1;\n            };\n        }\n        function extend(dest, source, callback) {\n            for (var index = -1, props = Object.keys(source), length = props.length, ask = isFunction(callback); ++index < length; ) {\n                var key = props[index];\n                dest[key] = ask ? callback(dest[key], source[key], key, dest, source) : source[key];\n            }\n            return dest;\n        }\n        function forEach(array, callback, thisArg) {\n            for (var i = 0, n = array.length; n > i; i++) {\n                var result = callback.call(thisArg, array[i], i, array);\n                if (result !== undefined$1) return result;\n            }\n        }\n        function identity(value) {\n            return value;\n        }\n        function isDefined(value) {\n            return value !== undefined$1;\n        }\n        function isArray(value) {\n            return value && \"object\" == typeof value && \"number\" == typeof value.length && \"[object Array]\" === Object.prototype.toString.call(value) || !1;\n        }\n        function isElement(value) {\n            return value && 1 === value.nodeType || !1;\n        }\n        function isFunction(value) {\n            return \"function\" == typeof value || !1;\n        }\n        function isObject(value) {\n            var type = typeof value;\n            return \"function\" === type || value && \"object\" === type || !1;\n        }\n        function noop() {}\n        function now() {\n            return new Date().getTime();\n        }\n        function once(callback) {\n            var cache, called = !1;\n            return function() {\n                return called || (cache = callback.apply(undefined$1, arguments), called = !0), cache;\n            };\n        }\n        function throttle(callback, wait, thisArg) {\n            var cancel = noop, last = !1;\n            return function() {\n                var time = now(), args = arguments, func = function() {\n                    last = time, callback.apply(thisArg, args);\n                };\n                last && last + wait > time ? (cancel(), cancel = defer(func, wait)) : (last = time, \n                defer(func, 0));\n            };\n        }\n        function viewport(referenceWindow) {\n            var win = referenceWindow || window;\n            return {\n                height: win.innerHeight,\n                width: win.innerWidth\n            };\n        }\n        function computedStyle(element, referenceWindow) {\n            return (referenceWindow || window).getComputedStyle(element, null);\n        }\n        function styleProperty(style, property) {\n            return style.getPropertyValue(property);\n        }\n        function isDisplayed(element, style) {\n            style || (style = computedStyle(element));\n            var display = styleProperty(style, \"display\");\n            if (\"none\" === display) return !1;\n            var parent = element.parentNode;\n            return isElement(parent) ? isDisplayed(parent) : !0;\n        }\n        function isVisibleByStyling(element, referenceWindow) {\n            if (element === (referenceWindow || window).document) return !0;\n            if (!element || !element.parentNode) return !1;\n            var style = computedStyle(element, referenceWindow), visibility = styleProperty(style, \"visibility\");\n            return \"hidden\" === visibility || \"collapse\" === visibility ? !1 : isDisplayed(element, style);\n        }\n        function isInViewport(rect, viewport) {\n            return !rect || rect.width <= 0 || rect.height <= 0 ? !1 : rect.bottom > 0 && rect.right > 0 && rect.top < viewport.height && rect.left < viewport.width;\n        }\n        function percentage(element, referenceWindow) {\n            var rect = element.getBoundingClientRect(), view = viewport(referenceWindow);\n            if (!isInViewport(rect, view) || !isVisibleByStyling(element)) return 0;\n            var vh = 0, vw = 0;\n            return rect.top >= 0 ? vh = Math.min(rect.height, view.height - rect.top) : rect.bottom > 0 && (vh = Math.min(view.height, rect.bottom)), \n            rect.left >= 0 ? vw = Math.min(rect.width, view.width - rect.left) : rect.right > 0 && (vw = Math.min(view.width, rect.right)), \n            vh * vw / (rect.height * rect.width);\n        }\n        function isPageVisible(referenceWindow) {\n            return !createVisibilityApi(referenceWindow || window).isHidden();\n        }\n        function VisSense(element, config) {\n            if (!(this instanceof VisSense)) return new VisSense(element, config);\n            if (!isElement(element)) throw new Error(\"not an element node\");\n            this._element = element, this._config = defaults(config, {\n                fullyvisible: 1,\n                hidden: 0,\n                referenceWindow: window,\n                percentageHook: percentage,\n                precision: 3,\n                visibilityHooks: []\n            });\n            var roundFactor = this._config.precision <= 0 ? 1 : Math.pow(10, this._config.precision || 3);\n            this._round = function(val) {\n                return Math.round(val * roundFactor) / roundFactor;\n            };\n            var visibilityApi = createVisibilityApi(this._config.referenceWindow);\n            this._config.visibilityHooks.push(function() {\n                return !visibilityApi.isHidden();\n            });\n        }\n        function nextState(visobj, currentState) {\n            var newState = visobj.state(), percentage = newState.percentage;\n            return currentState && percentage === currentState.percentage && currentState.percentage === currentState.previous.percentage ? currentState : newState.hidden ? VisSense.VisState.hidden(percentage, currentState) : newState.fullyvisible ? VisSense.VisState.fullyvisible(percentage, currentState) : VisSense.VisState.visible(percentage, currentState);\n        }\n        function VisMon(visobj, config) {\n            var _config = defaults(config, {\n                strategy: [ new VisMon.Strategy.PollingStrategy(), new VisMon.Strategy.EventStrategy() ],\n                async: !1\n            });\n            this._visobj = visobj, this._state = {}, this._started = !1;\n            var anyTopicName = \"*#\" + now();\n            this._pubsub = new PubSub({\n                async: _config.async,\n                anyTopicName: anyTopicName\n            }), this._events = [ anyTopicName, \"start\", \"stop\", \"update\", \"hidden\", \"visible\", \"fullyvisible\", \"percentagechange\", \"visibilitychange\" ], \n            this._strategy = new VisMon.Strategy.CompositeStrategy(_config.strategy), this._strategy.init(this), \n            this._pubsub.on(\"update\", function(monitor) {\n                var newValue = monitor._state.percentage, oldValue = monitor._state.previous.percentage;\n                newValue !== oldValue && monitor._pubsub.publish(\"percentagechange\", [ monitor, newValue, oldValue ]);\n            }), this._pubsub.on(\"update\", function(monitor) {\n                monitor._state.code !== monitor._state.previous.code && monitor._pubsub.publish(\"visibilitychange\", [ monitor ]);\n            }), this._pubsub.on(\"visibilitychange\", function(monitor) {\n                monitor._state.visible && !monitor._state.previous.visible && monitor._pubsub.publish(\"visible\", [ monitor ]);\n            }), this._pubsub.on(\"visibilitychange\", function(monitor) {\n                monitor._state.fullyvisible && monitor._pubsub.publish(\"fullyvisible\", [ monitor ]);\n            }), this._pubsub.on(\"visibilitychange\", function(monitor) {\n                monitor._state.hidden && monitor._pubsub.publish(\"hidden\", [ monitor ]);\n            }), forEach(this._events, function(event) {\n                isFunction(_config[event]) && this.on(event, _config[event]);\n            }, this);\n        }\n        var createVisibilityApi = function(referenceWindow) {\n            return function(document, undefined$1) {\n                var entry = function(propertyName, eventName) {\n                    return {\n                        property: propertyName,\n                        event: eventName\n                    };\n                }, event = \"visibilitychange\", dict = [ entry(\"webkitHidden\", \"webkit\" + event), entry(\"msHidden\", \"ms\" + event), entry(\"mozHidden\", \"moz\" + event), entry(\"hidden\", event) ], api = forEach(dict, function(entry) {\n                    return document[entry.property] !== undefined$1 ? {\n                        isHidden: function() {\n                            return !!document[entry.property] || !1;\n                        },\n                        onVisibilityChange: function(callback) {\n                            return document.addEventListener(entry.event, callback, !1), function() {\n                                document.removeEventListener(entry.event, callback, !1);\n                            };\n                        }\n                    } : void 0;\n                });\n                return api || {\n                    isHidden: function() {\n                        return !1;\n                    },\n                    onVisibilityChange: function() {\n                        return noop;\n                    }\n                };\n            }((referenceWindow || window).document);\n        }, PubSub = function(undefined$1) {\n            function PubSub(config) {\n                this._cache = {}, this._onAnyCache = [], this._config = defaults(config, {\n                    async: !1,\n                    anyTopicName: \"*\"\n                });\n            }\n            var syncFireListeners = function(consumers, args) {\n                forEach(consumers, function(consumer) {\n                    consumer(args);\n                });\n            };\n            return PubSub.prototype.on = function(topic, callback) {\n                if (!isFunction(callback)) return noop;\n                var applyCallback = function(args) {\n                    return callback.apply(undefined$1, args || []);\n                }, listener = this._config.async ? async(applyCallback) : applyCallback, unregister = function(listener, array, topic) {\n                    return function() {\n                        var index = array.indexOf(listener);\n                        return index > -1 ? (array.splice(index, 1), !0) : !1;\n                    };\n                };\n                return topic === this._config.anyTopicName ? (this._onAnyCache.push(listener), unregister(listener, this._onAnyCache)) : (this._cache[topic] || (this._cache[topic] = []), \n                this._cache[topic].push(listener), unregister(listener, this._cache[topic]));\n            }, PubSub.prototype.publish = function(topic, args) {\n                var listeners = (this._cache[topic] || []).concat(topic === this._config.anyTopicName ? [] : this._onAnyCache), enableAsync = !!this._config.async, syncOrAsyncPublish = enableAsync ? async(syncFireListeners) : function(listeners, args) {\n                    return syncFireListeners(listeners, args), noop;\n                };\n                return syncOrAsyncPublish(listeners, args || []);\n            }, PubSub;\n        }();\n        VisSense.prototype.state = function() {\n            var hiddenByHook = forEach(this._config.visibilityHooks, function(hook) {\n                return hook(this._element) ? void 0 : VisSense.VisState.hidden(0);\n            }, this);\n            return hiddenByHook || function(visobj, element, config) {\n                var perc = visobj._round(config.percentageHook(element, config.referenceWindow));\n                return perc <= config.hidden ? VisSense.VisState.hidden(perc) : perc >= config.fullyvisible ? VisSense.VisState.fullyvisible(perc) : VisSense.VisState.visible(perc);\n            }(this, this._element, this._config);\n        }, VisSense.prototype.percentage = function() {\n            return this.state().percentage;\n        }, VisSense.prototype.element = function() {\n            return this._element;\n        }, VisSense.prototype.referenceWindow = function() {\n            return this._config.referenceWindow;\n        }, VisSense.prototype.isFullyVisible = function() {\n            return this.state().fullyvisible;\n        }, VisSense.prototype.isVisible = function() {\n            return this.state().visible;\n        }, VisSense.prototype.isHidden = function() {\n            return this.state().hidden;\n        }, VisSense.fn = VisSense.prototype, VisSense.of = function(element, config) {\n            return new VisSense(element, config);\n        };\n        var STATES = {\n            HIDDEN: [ 0, \"hidden\" ],\n            VISIBLE: [ 1, \"visible\" ],\n            FULLY_VISIBLE: [ 2, \"fullyvisible\" ]\n        };\n        return VisSense.VisState = function() {\n            function newVisState(state, percentage, previous) {\n                return previous && delete previous.previous, {\n                    code: state[0],\n                    state: state[1],\n                    percentage: percentage,\n                    previous: previous || {},\n                    fullyvisible: state[0] === STATES.FULLY_VISIBLE[0],\n                    visible: state[0] === STATES.VISIBLE[0] || state[0] === STATES.FULLY_VISIBLE[0],\n                    hidden: state[0] === STATES.HIDDEN[0]\n                };\n            }\n            return {\n                hidden: function(percentage, previous) {\n                    return newVisState(STATES.HIDDEN, percentage, previous);\n                },\n                visible: function(percentage, previous) {\n                    return newVisState(STATES.VISIBLE, percentage, previous);\n                },\n                fullyvisible: function(percentage, previous) {\n                    return newVisState(STATES.FULLY_VISIBLE, percentage, previous);\n                }\n            };\n        }(), VisMon.prototype.visobj = function() {\n            return this._visobj;\n        }, VisMon.prototype.publish = function(eventName, args) {\n            var isInternalEvent = this._events.indexOf(eventName) >= 0;\n            if (isInternalEvent) throw new Error('Cannot publish internal event \"' + eventName + '\" from external scope.');\n            return this._pubsub.publish(eventName, args);\n        }, VisMon.prototype.state = function() {\n            return this._state;\n        }, VisMon.prototype.start = function(config) {\n            if (this._started) return this;\n            var _config = defaults(config, {\n                async: !1\n            });\n            return this._cancelAsyncStart && this._cancelAsyncStart(), _config.async ? this.startAsync() : (this._started = !0, \n            this.update(), this._pubsub.publish(\"start\", [ this ]), this._strategy.start(this), \n            this);\n        }, VisMon.prototype.startAsync = function(config) {\n            this._cancelAsyncStart && this._cancelAsyncStart();\n            var me = this, cancelAsyncStart = defer(function() {\n                me.start(extend(defaults(config, {}), {\n                    async: !1\n                }));\n            });\n            return this._cancelAsyncStart = function() {\n                cancelAsyncStart(), me._cancelAsyncStart = null;\n            }, this;\n        }, VisMon.prototype.stop = function() {\n            this._cancelAsyncStart && this._cancelAsyncStart(), this._started && (this._strategy.stop(this), \n            this._pubsub.publish(\"stop\", [ this ])), this._started = !1;\n        }, VisMon.prototype.update = function() {\n            this._started && (this._state = nextState(this._visobj, this._state), this._pubsub.publish(\"update\", [ this ]));\n        }, VisMon.prototype.on = function(topic, callback) {\n            return this._pubsub.on(topic, callback);\n        }, VisMon.Builder = function() {\n            var combineStrategies = function(config, strategies) {\n                var combinedStrategies = null, forceDisableStrategies = config.strategy === !1, enableStrategies = !forceDisableStrategies && (config.strategy || strategies.length > 0);\n                if (enableStrategies) {\n                    var configStrategyIsDefined = !!config.strategy, configStrategyIsArray = isArray(config.strategy), configStrategyAsArray = configStrategyIsDefined ? configStrategyIsArray ? config.strategy : [ config.strategy ] : [];\n                    combinedStrategies = configStrategyAsArray.concat(strategies);\n                } else combinedStrategies = forceDisableStrategies ? [] : config.strategy;\n                return combinedStrategies;\n            };\n            return function(visobj) {\n                var config = {}, strategies = [], events = [], productBuilt = !1, product = null;\n                return {\n                    set: function(name, value) {\n                        return config[name] = value, this;\n                    },\n                    strategy: function(strategy) {\n                        return strategies.push(strategy), this;\n                    },\n                    on: function(event, handler) {\n                        return events.push([ event, handler ]), this;\n                    },\n                    build: function(consumer) {\n                        var manufacture = function() {\n                            var combinedStrategies = combineStrategies(config, strategies);\n                            config.strategy = combinedStrategies;\n                            var monitor = visobj.monitor(config);\n                            return forEach(events, function(event) {\n                                monitor.on(event[0], event[1]);\n                            }), productBuilt = !0, product = monitor;\n                        }, monitor = productBuilt ? product : manufacture();\n                        return isFunction(consumer) ? consumer(monitor) : monitor;\n                    }\n                };\n            };\n        }(), VisMon.Strategy = function() {}, VisMon.Strategy.prototype.init = noop, VisMon.Strategy.prototype.start = noop, \n        VisMon.Strategy.prototype.stop = noop, VisMon.Strategy.CompositeStrategy = function(strategies) {\n            this._strategies = isArray(strategies) ? strategies : [ strategies ];\n        }, VisMon.Strategy.CompositeStrategy.prototype = Object.create(VisMon.Strategy.prototype), \n        VisMon.Strategy.CompositeStrategy.prototype.init = function(monitor) {\n            forEach(this._strategies, function(strategy) {\n                isFunction(strategy.init) && strategy.init(monitor);\n            });\n        }, VisMon.Strategy.CompositeStrategy.prototype.start = function(monitor) {\n            forEach(this._strategies, function(strategy) {\n                isFunction(strategy.start) && strategy.start(monitor);\n            });\n        }, VisMon.Strategy.CompositeStrategy.prototype.stop = function(monitor) {\n            forEach(this._strategies, function(strategy) {\n                isFunction(strategy.stop) && strategy.stop(monitor);\n            });\n        }, VisMon.Strategy.PollingStrategy = function(config) {\n            this._config = defaults(config, {\n                interval: 1e3\n            }), this._started = !1;\n        }, VisMon.Strategy.PollingStrategy.prototype = Object.create(VisMon.Strategy.prototype), \n        VisMon.Strategy.PollingStrategy.prototype.start = function(monitor) {\n            return this._started || (this._clearInterval = function(interval) {\n                var intervalId = setInterval(function() {\n                    monitor.update();\n                }, interval);\n                return function() {\n                    clearInterval(intervalId);\n                };\n            }(this._config.interval), this._started = !0), this._started;\n        }, VisMon.Strategy.PollingStrategy.prototype.stop = function() {\n            return this._started ? (this._clearInterval(), this._started = !1, !0) : !1;\n        }, VisMon.Strategy.EventStrategy = function(config) {\n            this._config = defaults(config, {\n                throttle: 50\n            }), this._config.debounce > 0 && (this._config.throttle = +this._config.debounce), \n            this._started = !1;\n        }, VisMon.Strategy.EventStrategy.prototype = Object.create(VisMon.Strategy.prototype), \n        VisMon.Strategy.EventStrategy.prototype.start = function(monitor) {\n            return this._started || (this._removeEventListeners = function(update) {\n                var referenceWindow = monitor.visobj().referenceWindow(), visibilityApi = createVisibilityApi(referenceWindow), removeOnVisibilityChangeEvent = visibilityApi.onVisibilityChange(update);\n                return referenceWindow.addEventListener(\"scroll\", update, !1), referenceWindow.addEventListener(\"resize\", update, !1), \n                referenceWindow.addEventListener(\"touchmove\", update, !1), function() {\n                    referenceWindow.removeEventListener(\"touchmove\", update, !1), referenceWindow.removeEventListener(\"resize\", update, !1), \n                    referenceWindow.removeEventListener(\"scroll\", update, !1), removeOnVisibilityChangeEvent();\n                };\n            }(throttle(function() {\n                monitor.update();\n            }, this._config.throttle)), this._started = !0), this._started;\n        }, VisMon.Strategy.EventStrategy.prototype.stop = function() {\n            return this._started ? (this._removeEventListeners(), this._started = !1, !0) : !1;\n        }, VisSense.VisMon = VisMon, VisSense.PubSub = PubSub, VisSense.fn.monitor = function(config) {\n            return new VisMon(this, config);\n        }, VisSense.Utils = {\n            async: async,\n            debounce: debounce,\n            defaults: defaults,\n            defer: defer,\n            extend: extend,\n            forEach: forEach,\n            fireIf: fireIf,\n            identity: identity,\n            isArray: isArray,\n            isDefined: isDefined,\n            isElement: isElement,\n            isFunction: isFunction,\n            isObject: isObject,\n            isPageVisible: isPageVisible,\n            isVisibleByStyling: isVisibleByStyling,\n            noop: noop,\n            now: now,\n            once: once,\n            throttle: throttle,\n            percentage: percentage,\n            VisibilityApi: createVisibilityApi(),\n            createVisibilityApi: createVisibilityApi,\n            _viewport: viewport,\n            _isInViewport: isInViewport,\n            _isDisplayed: isDisplayed,\n            _computedStyle: computedStyle,\n            _styleProperty: styleProperty\n        }, VisSense;\n    });\n    });\n\n    var VisSense = vissense(window);\r\n    var VisSenseUtils = VisSense.Utils;\r\n    var createInnerMonitor = function (outerMonitor, callback, config) {\r\n        var timeElapsed = 0;\r\n        var timeStarted = null;\r\n        var timeLimit = config.timeLimit;\r\n        var percentageLimit = config.percentageLimit;\r\n        var interval = config.interval;\r\n        return VisSense.VisMon.Builder(outerMonitor.visobj())\r\n            .strategy(new VisSense.VisMon.Strategy.PollingStrategy({ interval: interval }))\r\n            .on('update', function (monitor) {\r\n            var percentage = monitor.state().percentage;\r\n            if (percentage < percentageLimit) {\r\n                timeStarted = null;\r\n            }\r\n            else {\r\n                var now = VisSenseUtils.now();\r\n                timeStarted = timeStarted || now;\r\n                timeElapsed = now - timeStarted;\r\n            }\r\n            if (timeElapsed >= timeLimit) {\r\n                monitor.stop();\r\n                outerMonitor.stop();\r\n                callback(monitor);\r\n            }\r\n        })\r\n            .on('stop', function () {\r\n            timeStarted = null;\r\n        })\r\n            .build();\r\n    };\r\n    var onPercentageTimeTestPassed = function (visobj, callback, config) {\r\n        var _config = VisSenseUtils.defaults(config, {\r\n            percentageLimit: 1,\r\n            timeLimit: 1000,\r\n            interval: 100,\r\n            strategy: undefined\r\n        });\r\n        // monitor is considered hidden if it is 1% below the percentage limit\r\n        var hiddenLimit = Math.max(_config.percentageLimit - 0.001, 0);\r\n        var innerMonitor = null;\r\n        var outerMonitor = VisSense.VisMon.Builder(new VisSense(visobj.element(), {\r\n            hidden: hiddenLimit,\r\n            referenceWindow: visobj.referenceWindow()\r\n        }))\r\n            .set('strategy', _config.strategy)\r\n            .on('visible', function (monitor) {\r\n            if (innerMonitor === null) {\r\n                innerMonitor = createInnerMonitor(monitor, callback, _config);\r\n            }\r\n            innerMonitor.start();\r\n        })\r\n            .on('hidden', function () {\r\n            if (innerMonitor !== null) {\r\n                innerMonitor.stop();\r\n            }\r\n        })\r\n            .on('stop', function () {\r\n            if (innerMonitor !== null) {\r\n                innerMonitor.stop();\r\n            }\r\n        })\r\n            .build();\r\n        outerMonitor.start();\r\n        return function () {\r\n            outerMonitor.stop();\r\n            innerMonitor = null;\r\n        };\r\n    };\r\n    VisSense.fn.onPercentageTimeTestPassed = function (callback, config) {\r\n        onPercentageTimeTestPassed(this, callback, config);\r\n    };\n\n    /**\r\n     *埋点入口类\r\n     *\r\n     * @class ActionTracker\r\n     */\r\n    var ActionTracker = /** @class */ (function () {\r\n        function ActionTracker() {\r\n        }\r\n        ActionTracker.getInstance = function () {\r\n            if (!ActionTracker.instance) {\r\n                ActionTracker.instance = new ActionTracker();\r\n            }\r\n            return ActionTracker.instance;\r\n        };\r\n        /**\r\n         * 埋点页面,如果需要埋页面时间重置时间 发送放pageChange发\r\n         * @memberof ActionTracker\r\n         */\r\n        ActionTracker.prototype.trackPage = function (info) {\r\n            if (info === void 0) { info = {}; }\r\n            var config = getConfig();\r\n            if (config.pageTime) {\r\n                instance.end();\r\n            }\r\n            var data = __assign({ actionType: ACTION_TYPE.PAGE }, info);\r\n            //修改当前pageInfo\r\n            var _a = getPageInfo(), pageId = _a.pageId, url = _a.url;\r\n            setPageInfo({ pageId: data.trackId || '', referrerId: pageId || '', referrerUrl: url || '' });\r\n            send(data);\r\n            if (config.pageTime) {\r\n                instance.start(data);\r\n            }\r\n        };\r\n        /**\r\n         * 时长埋点\r\n         * @memberof ActionTracker\r\n         */\r\n        ActionTracker.prototype.trackDuration = function (info) {\r\n            if (info === void 0) { info = {}; }\r\n            var data = __assign({ actionType: ACTION_TYPE.DURATION }, info);\r\n            send(data);\r\n        };\r\n        /**\r\n         *\r\n         *事件埋点\r\n         */\r\n        ActionTracker.prototype.trackEvent = function (info) {\r\n            if (info === void 0) { info = {}; }\r\n            var data = __assign({ actionType: ACTION_TYPE.EVENT, eventName: 'CLICK' }, info);\r\n            send(data);\r\n        };\r\n        /**\r\n         * 视窗埋点 暂时不启用\r\n         * @param dom\r\n         * @param info\r\n         * @param visSenseConfig\r\n         */\r\n        ActionTracker.prototype.trackView = function (dom, info, visSenseConfig) {\r\n            if (visSenseConfig === void 0) { visSenseConfig = {}; }\r\n            var data = __assign({ actionType: ACTION_TYPE.VIEW, domId: dom.id, domClass: dom.className, domTag: dom.tagName, domContent: dom.textContent.substr(0, 20), domPath: getDomPath(dom) }, info);\r\n            var visobj = VisSense(dom);\r\n            visobj.onPercentageTimeTestPassed(function () {\r\n                send(data);\r\n            }, {\r\n                percentageLimit: visSenseConfig.percentageLimit || 0.5,\r\n                timeLimit: visSenseConfig.timeLimit || 1000,\r\n                interval: 200\r\n            });\r\n        };\r\n        /**\r\n         *通用埋点入口 埋点类型自行控制\r\n         *\r\n         */\r\n        ActionTracker.prototype.track = function (info) {\r\n            switch (info.actionType) {\r\n                case ACTION_TYPE.EVENT:\r\n                    this.trackEvent(info);\r\n                    break;\r\n                case ACTION_TYPE.PAGE:\r\n                    this.trackPage(info);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            send(info);\r\n        };\r\n        /**\r\n         * a标签埋点 做300毫秒延迟跳转 确保埋点成功\r\n         * @param linkDom\r\n         * @param info\r\n         */\r\n        ActionTracker.prototype.trackLink = function (linkDom, info) {\r\n            if (info === void 0) { info = {}; }\r\n            var config = getConfig();\r\n            if (config.delayLink) {\r\n                linkDom.addEventListener('click', function (e) {\r\n                    e.preventDefault();\r\n                    setTimeout(function () {\r\n                        linkDom.click();\r\n                    }, config.delayLinkTime);\r\n                }, false);\r\n            }\r\n            this.trackDom(linkDom, info);\r\n            sendAsync();\r\n        };\r\n        /**\r\n         *埋点dom 做1秒防抖\r\n         *\r\n         * @param {(HTMLLinkElement | HTMLInputElement | HTMLLinkElement)} dom\r\n         * @param {ITrackerData} [info={}]\r\n         * @returns\r\n         * @memberof ActionTracker\r\n         */\r\n        ActionTracker.prototype.trackDom = function (dom, info) {\r\n            if (info === void 0) { info = {}; }\r\n            //防止频繁触发\r\n            var _dom = dom;\r\n            if (_dom.IS_TRACKED) {\r\n                clearTimeout(_dom.DELAY_TRACK_TIME);\r\n                _dom.DELAY_TRACK_TIME = setTimeout(function () {\r\n                    _dom.IS_TRACKED = false;\r\n                }, 1000);\r\n                return;\r\n            }\r\n            _dom.IS_TRACKED = true;\r\n            _dom.DELAY_TRACK_TIME = setTimeout(function () {\r\n                _dom.IS_TRACKED = false;\r\n            }, 1000);\r\n            var trackInfo = {\r\n                trackId: '',\r\n                domId: dom.id,\r\n                domClass: dom.className,\r\n                domHref: dom.href || '',\r\n                domName: dom.name || '',\r\n                domTag: dom.tagName,\r\n                domContent: dom.textContent.substr(0, 20),\r\n                domPath: getDomPath(dom)\r\n            };\r\n            var track = dom.getAttribute('data-track');\r\n            if (track && track.search(/^\\{[\\S\\s]*\\}$/) >= 0) {\r\n                trackInfo = __assign(__assign({}, trackInfo), JSON.parse(track));\r\n            }\r\n            else {\r\n                trackInfo.trackId = track || '';\r\n            }\r\n            if (info) {\r\n                trackInfo = __assign(__assign({}, trackInfo), info);\r\n            }\r\n            this.trackEvent(trackInfo);\r\n        };\r\n        ActionTracker.instance = null;\r\n        return ActionTracker;\r\n    }());\r\n    var instance$1 = ActionTracker.getInstance();\n\n    /**\n     * Optimized internal three-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n\n    function _curry3(fn) {\n      return function f3(a, b, c) {\n        switch (arguments.length) {\n          case 0:\n            return f3;\n\n          case 1:\n            return _isPlaceholder_1(a) ? f3 : _curry2_1(function (_b, _c) {\n              return fn(a, _b, _c);\n            });\n\n          case 2:\n            return _isPlaceholder_1(a) && _isPlaceholder_1(b) ? f3 : _isPlaceholder_1(a) ? _curry2_1(function (_a, _c) {\n              return fn(_a, b, _c);\n            }) : _isPlaceholder_1(b) ? _curry2_1(function (_b, _c) {\n              return fn(a, _b, _c);\n            }) : _curry1_1(function (_c) {\n              return fn(a, b, _c);\n            });\n\n          default:\n            return _isPlaceholder_1(a) && _isPlaceholder_1(b) && _isPlaceholder_1(c) ? f3 : _isPlaceholder_1(a) && _isPlaceholder_1(b) ? _curry2_1(function (_a, _b) {\n              return fn(_a, _b, c);\n            }) : _isPlaceholder_1(a) && _isPlaceholder_1(c) ? _curry2_1(function (_a, _c) {\n              return fn(_a, b, _c);\n            }) : _isPlaceholder_1(b) && _isPlaceholder_1(c) ? _curry2_1(function (_b, _c) {\n              return fn(a, _b, _c);\n            }) : _isPlaceholder_1(a) ? _curry1_1(function (_a) {\n              return fn(_a, b, c);\n            }) : _isPlaceholder_1(b) ? _curry1_1(function (_b) {\n              return fn(a, _b, c);\n            }) : _isPlaceholder_1(c) ? _curry1_1(function (_c) {\n              return fn(a, b, _c);\n            }) : fn(a, b, c);\n        }\n      };\n    }\n\n    var _curry3_1 = _curry3;\n\n    /**\n     * Returns a function that always returns the given value. Note that for\n     * non-primitives the value returned is a reference to the original value.\n     *\n     * This function is known as `const`, `constant`, or `K` (for K combinator) in\n     * other languages and libraries.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig a -> (* -> a)\n     * @param {*} val The value to wrap in a function\n     * @return {Function} A Function :: * -> val.\n     * @example\n     *\n     *      const t = R.always('Tee');\n     *      t(); //=> 'Tee'\n     */\n\n\n    var always =\n    /*#__PURE__*/\n    _curry1_1(function always(val) {\n      return function () {\n        return val;\n      };\n    });\n\n    var always_1 = always;\n\n    // `Identity` is a functor that holds a single value, where `map` simply\n    // transforms the held value with the provided function.\n\n\n    var Identity = function (x) {\n      return {\n        value: x,\n        map: function (f) {\n          return Identity(f(x));\n        }\n      };\n    };\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the result of applying the given function to\n     * the focused value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> (a -> a) -> s -> s\n     * @param {Lens} lens\n     * @param {*} v\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      const headLens = R.lensIndex(0);\n     *\n     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']\n     */\n\n\n    var over =\n    /*#__PURE__*/\n    _curry3_1(function over(lens, f, x) {\n      // The value returned by the getter function is first transformed with `f`,\n      // then set as the value of an `Identity`. This is then mapped over with the\n      // setter function of the lens.\n      return lens(function (y) {\n        return Identity(f(y));\n      })(x).value;\n    });\n\n    var over_1 = over;\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the given value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> a -> s -> s\n     * @param {Lens} lens\n     * @param {*} v\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      const xLens = R.lensProp('x');\n     *\n     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}\n     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}\n     */\n\n\n    var set =\n    /*#__PURE__*/\n    _curry3_1(function set(lens, v, x) {\n      return over_1(lens, always_1(v), x);\n    });\n\n    var set_1 = set;\n\n    function _isPlaceholder$1(a) {\n      return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n    }\n\n    /**\n     * Optimized internal one-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n    function _curry1$1(fn) {\n      return function f1(a) {\n        if (arguments.length === 0 || _isPlaceholder$1(a)) {\n          return f1;\n        } else {\n          return fn.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Optimized internal two-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n    function _curry2$1(fn) {\n      return function f2(a, b) {\n        switch (arguments.length) {\n          case 0:\n            return f2;\n\n          case 1:\n            return _isPlaceholder$1(a) ? f2 : _curry1$1(function (_b) {\n              return fn(a, _b);\n            });\n\n          default:\n            return _isPlaceholder$1(a) && _isPlaceholder$1(b) ? f2 : _isPlaceholder$1(a) ? _curry1$1(function (_a) {\n              return fn(_a, b);\n            }) : _isPlaceholder$1(b) ? _curry1$1(function (_b) {\n              return fn(a, _b);\n            }) : fn(a, b);\n        }\n      };\n    }\n\n    function _arity(n, fn) {\n      /* eslint-disable no-unused-vars */\n      switch (n) {\n        case 0:\n          return function () {\n            return fn.apply(this, arguments);\n          };\n\n        case 1:\n          return function (a0) {\n            return fn.apply(this, arguments);\n          };\n\n        case 2:\n          return function (a0, a1) {\n            return fn.apply(this, arguments);\n          };\n\n        case 3:\n          return function (a0, a1, a2) {\n            return fn.apply(this, arguments);\n          };\n\n        case 4:\n          return function (a0, a1, a2, a3) {\n            return fn.apply(this, arguments);\n          };\n\n        case 5:\n          return function (a0, a1, a2, a3, a4) {\n            return fn.apply(this, arguments);\n          };\n\n        case 6:\n          return function (a0, a1, a2, a3, a4, a5) {\n            return fn.apply(this, arguments);\n          };\n\n        case 7:\n          return function (a0, a1, a2, a3, a4, a5, a6) {\n            return fn.apply(this, arguments);\n          };\n\n        case 8:\n          return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n            return fn.apply(this, arguments);\n          };\n\n        case 9:\n          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n            return fn.apply(this, arguments);\n          };\n\n        case 10:\n          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            return fn.apply(this, arguments);\n          };\n\n        default:\n          throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n      }\n    }\n\n    /**\n     * Internal curryN function.\n     *\n     * @private\n     * @category Function\n     * @param {Number} length The arity of the curried function.\n     * @param {Array} received An array of arguments received thus far.\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n    function _curryN(length, received, fn) {\n      return function () {\n        var combined = [];\n        var argsIdx = 0;\n        var left = length;\n        var combinedIdx = 0;\n\n        while (combinedIdx < received.length || argsIdx < arguments.length) {\n          var result;\n\n          if (combinedIdx < received.length && (!_isPlaceholder$1(received[combinedIdx]) || argsIdx >= arguments.length)) {\n            result = received[combinedIdx];\n          } else {\n            result = arguments[argsIdx];\n            argsIdx += 1;\n          }\n\n          combined[combinedIdx] = result;\n\n          if (!_isPlaceholder$1(result)) {\n            left -= 1;\n          }\n\n          combinedIdx += 1;\n        }\n\n        return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n      };\n    }\n\n    /**\n     * Returns a curried equivalent of the provided function, with the specified\n     * arity. The curried function has two unusual capabilities. First, its\n     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n     * following are equivalent:\n     *\n     *   - `g(1)(2)(3)`\n     *   - `g(1)(2, 3)`\n     *   - `g(1, 2)(3)`\n     *   - `g(1, 2, 3)`\n     *\n     * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n     * \"gaps\", allowing partial application of any combination of arguments,\n     * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n     * the following are equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @func\n     * @memberOf R\n     * @since v0.5.0\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} length The arity for the returned function.\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curry\n     * @example\n     *\n     *      const sumArgs = (...args) => R.sum(args);\n     *\n     *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n     *      const f = curriedAddFourNumbers(1, 2);\n     *      const g = f(3);\n     *      g(4); //=> 10\n     */\n\n    var curryN =\n    /*#__PURE__*/\n    _curry2$1(function curryN(length, fn) {\n      if (length === 1) {\n        return _curry1$1(fn);\n      }\n\n      return _arity(length, _curryN(length, [], fn));\n    });\n\n    /**\n     * Optimized internal three-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n    function _curry3$1(fn) {\n      return function f3(a, b, c) {\n        switch (arguments.length) {\n          case 0:\n            return f3;\n\n          case 1:\n            return _isPlaceholder$1(a) ? f3 : _curry2$1(function (_b, _c) {\n              return fn(a, _b, _c);\n            });\n\n          case 2:\n            return _isPlaceholder$1(a) && _isPlaceholder$1(b) ? f3 : _isPlaceholder$1(a) ? _curry2$1(function (_a, _c) {\n              return fn(_a, b, _c);\n            }) : _isPlaceholder$1(b) ? _curry2$1(function (_b, _c) {\n              return fn(a, _b, _c);\n            }) : _curry1$1(function (_c) {\n              return fn(a, b, _c);\n            });\n\n          default:\n            return _isPlaceholder$1(a) && _isPlaceholder$1(b) && _isPlaceholder$1(c) ? f3 : _isPlaceholder$1(a) && _isPlaceholder$1(b) ? _curry2$1(function (_a, _b) {\n              return fn(_a, _b, c);\n            }) : _isPlaceholder$1(a) && _isPlaceholder$1(c) ? _curry2$1(function (_a, _c) {\n              return fn(_a, b, _c);\n            }) : _isPlaceholder$1(b) && _isPlaceholder$1(c) ? _curry2$1(function (_b, _c) {\n              return fn(a, _b, _c);\n            }) : _isPlaceholder$1(a) ? _curry1$1(function (_a) {\n              return fn(_a, b, c);\n            }) : _isPlaceholder$1(b) ? _curry1$1(function (_b) {\n              return fn(a, _b, c);\n            }) : _isPlaceholder$1(c) ? _curry1$1(function (_c) {\n              return fn(a, b, _c);\n            }) : fn(a, b, c);\n        }\n      };\n    }\n\n    /**\n     * Tests whether or not an object is an array.\n     *\n     * @private\n     * @param {*} val The object to test.\n     * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n     * @example\n     *\n     *      _isArray([]); //=> true\n     *      _isArray(null); //=> false\n     *      _isArray({}); //=> false\n     */\n    var _isArray = Array.isArray || function _isArray(val) {\n      return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n    };\n\n    function _isTransformer(obj) {\n      return obj != null && typeof obj['@@transducer/step'] === 'function';\n    }\n\n    /**\n     * Returns a function that dispatches with different strategies based on the\n     * object in list position (last argument). If it is an array, executes [fn].\n     * Otherwise, if it has a function with one of the given method names, it will\n     * execute that function (functor case). Otherwise, if it is a transformer,\n     * uses transducer [xf] to return a new transformer (transducer case).\n     * Otherwise, it will default to executing [fn].\n     *\n     * @private\n     * @param {Array} methodNames properties to check for a custom implementation\n     * @param {Function} xf transducer to initialize if object is transformer\n     * @param {Function} fn default ramda implementation\n     * @return {Function} A function that dispatches on object in list position\n     */\n\n    function _dispatchable(methodNames, xf, fn) {\n      return function () {\n        if (arguments.length === 0) {\n          return fn();\n        }\n\n        var args = Array.prototype.slice.call(arguments, 0);\n        var obj = args.pop();\n\n        if (!_isArray(obj)) {\n          var idx = 0;\n\n          while (idx < methodNames.length) {\n            if (typeof obj[methodNames[idx]] === 'function') {\n              return obj[methodNames[idx]].apply(obj, args);\n            }\n\n            idx += 1;\n          }\n\n          if (_isTransformer(obj)) {\n            var transducer = xf.apply(null, args);\n            return transducer(obj);\n          }\n        }\n\n        return fn.apply(this, arguments);\n      };\n    }\n\n    var _xfBase = {\n      init: function () {\n        return this.xf['@@transducer/init']();\n      },\n      result: function (result) {\n        return this.xf['@@transducer/result'](result);\n      }\n    };\n\n    function _map(fn, functor) {\n      var idx = 0;\n      var len = functor.length;\n      var result = Array(len);\n\n      while (idx < len) {\n        result[idx] = fn(functor[idx]);\n        idx += 1;\n      }\n\n      return result;\n    }\n\n    function _isString(x) {\n      return Object.prototype.toString.call(x) === '[object String]';\n    }\n\n    /**\n     * Tests whether or not an object is similar to an array.\n     *\n     * @private\n     * @category Type\n     * @category List\n     * @sig * -> Boolean\n     * @param {*} x The object to test.\n     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n     * @example\n     *\n     *      _isArrayLike([]); //=> true\n     *      _isArrayLike(true); //=> false\n     *      _isArrayLike({}); //=> false\n     *      _isArrayLike({length: 10}); //=> false\n     *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n     */\n\n    var _isArrayLike =\n    /*#__PURE__*/\n    _curry1$1(function isArrayLike(x) {\n      if (_isArray(x)) {\n        return true;\n      }\n\n      if (!x) {\n        return false;\n      }\n\n      if (typeof x !== 'object') {\n        return false;\n      }\n\n      if (_isString(x)) {\n        return false;\n      }\n\n      if (x.nodeType === 1) {\n        return !!x.length;\n      }\n\n      if (x.length === 0) {\n        return true;\n      }\n\n      if (x.length > 0) {\n        return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n      }\n\n      return false;\n    });\n\n    var XWrap =\n    /*#__PURE__*/\n    function () {\n      function XWrap(fn) {\n        this.f = fn;\n      }\n\n      XWrap.prototype['@@transducer/init'] = function () {\n        throw new Error('init not implemented on XWrap');\n      };\n\n      XWrap.prototype['@@transducer/result'] = function (acc) {\n        return acc;\n      };\n\n      XWrap.prototype['@@transducer/step'] = function (acc, x) {\n        return this.f(acc, x);\n      };\n\n      return XWrap;\n    }();\n\n    function _xwrap(fn) {\n      return new XWrap(fn);\n    }\n\n    /**\n     * Creates a function that is bound to a context.\n     * Note: `R.bind` does not provide the additional argument-binding capabilities of\n     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Function\n     * @category Object\n     * @sig (* -> *) -> {*} -> (* -> *)\n     * @param {Function} fn The function to bind to context\n     * @param {Object} thisObj The context to bind `fn` to\n     * @return {Function} A function that will execute in the context of `thisObj`.\n     * @see R.partial\n     * @example\n     *\n     *      const log = R.bind(console.log, console);\n     *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}\n     *      // logs {a: 2}\n     * @symb R.bind(f, o)(a, b) = f.call(o, a, b)\n     */\n\n    var bind =\n    /*#__PURE__*/\n    _curry2$1(function bind(fn, thisObj) {\n      return _arity(fn.length, function () {\n        return fn.apply(thisObj, arguments);\n      });\n    });\n\n    function _arrayReduce(xf, acc, list) {\n      var idx = 0;\n      var len = list.length;\n\n      while (idx < len) {\n        acc = xf['@@transducer/step'](acc, list[idx]);\n\n        if (acc && acc['@@transducer/reduced']) {\n          acc = acc['@@transducer/value'];\n          break;\n        }\n\n        idx += 1;\n      }\n\n      return xf['@@transducer/result'](acc);\n    }\n\n    function _iterableReduce(xf, acc, iter) {\n      var step = iter.next();\n\n      while (!step.done) {\n        acc = xf['@@transducer/step'](acc, step.value);\n\n        if (acc && acc['@@transducer/reduced']) {\n          acc = acc['@@transducer/value'];\n          break;\n        }\n\n        step = iter.next();\n      }\n\n      return xf['@@transducer/result'](acc);\n    }\n\n    function _methodReduce(xf, acc, obj, methodName) {\n      return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));\n    }\n\n    var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n    function _reduce(fn, acc, list) {\n      if (typeof fn === 'function') {\n        fn = _xwrap(fn);\n      }\n\n      if (_isArrayLike(list)) {\n        return _arrayReduce(fn, acc, list);\n      }\n\n      if (typeof list['fantasy-land/reduce'] === 'function') {\n        return _methodReduce(fn, acc, list, 'fantasy-land/reduce');\n      }\n\n      if (list[symIterator] != null) {\n        return _iterableReduce(fn, acc, list[symIterator]());\n      }\n\n      if (typeof list.next === 'function') {\n        return _iterableReduce(fn, acc, list);\n      }\n\n      if (typeof list.reduce === 'function') {\n        return _methodReduce(fn, acc, list, 'reduce');\n      }\n\n      throw new TypeError('reduce: list must be array or iterable');\n    }\n\n    var XMap =\n    /*#__PURE__*/\n    function () {\n      function XMap(f, xf) {\n        this.xf = xf;\n        this.f = f;\n      }\n\n      XMap.prototype['@@transducer/init'] = _xfBase.init;\n      XMap.prototype['@@transducer/result'] = _xfBase.result;\n\n      XMap.prototype['@@transducer/step'] = function (result, input) {\n        return this.xf['@@transducer/step'](result, this.f(input));\n      };\n\n      return XMap;\n    }();\n\n    var _xmap =\n    /*#__PURE__*/\n    _curry2$1(function _xmap(f, xf) {\n      return new XMap(f, xf);\n    });\n\n    function _has$1(prop, obj) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    var toString$1 = Object.prototype.toString;\n\n    var _isArguments$1 =\n    /*#__PURE__*/\n    function () {\n      return toString$1.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n        return toString$1.call(x) === '[object Arguments]';\n      } : function _isArguments(x) {\n        return _has$1('callee', x);\n      };\n    }();\n\n    var hasEnumBug$1 = !\n    /*#__PURE__*/\n    {\n      toString: null\n    }.propertyIsEnumerable('toString');\n    var nonEnumerableProps$1 = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug\n\n    var hasArgsEnumBug$1 =\n    /*#__PURE__*/\n    function () {\n\n      return arguments.propertyIsEnumerable('length');\n    }();\n\n    var contains$1 = function contains(list, item) {\n      var idx = 0;\n\n      while (idx < list.length) {\n        if (list[idx] === item) {\n          return true;\n        }\n\n        idx += 1;\n      }\n\n      return false;\n    };\n    /**\n     * Returns a list containing the names of all the enumerable own properties of\n     * the supplied object.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own properties.\n     * @see R.keysIn, R.values\n     * @example\n     *\n     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n     */\n\n\n    var keys$1 = typeof Object.keys === 'function' && !hasArgsEnumBug$1 ?\n    /*#__PURE__*/\n    _curry1$1(function keys(obj) {\n      return Object(obj) !== obj ? [] : Object.keys(obj);\n    }) :\n    /*#__PURE__*/\n    _curry1$1(function keys(obj) {\n      if (Object(obj) !== obj) {\n        return [];\n      }\n\n      var prop, nIdx;\n      var ks = [];\n\n      var checkArgsLength = hasArgsEnumBug$1 && _isArguments$1(obj);\n\n      for (prop in obj) {\n        if (_has$1(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n          ks[ks.length] = prop;\n        }\n      }\n\n      if (hasEnumBug$1) {\n        nIdx = nonEnumerableProps$1.length - 1;\n\n        while (nIdx >= 0) {\n          prop = nonEnumerableProps$1[nIdx];\n\n          if (_has$1(prop, obj) && !contains$1(ks, prop)) {\n            ks[ks.length] = prop;\n          }\n\n          nIdx -= 1;\n        }\n      }\n\n      return ks;\n    });\n\n    /**\n     * Takes a function and\n     * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n     * applies the function to each of the functor's values, and returns\n     * a functor of the same shape.\n     *\n     * Ramda provides suitable `map` implementations for `Array` and `Object`,\n     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n     *\n     * Dispatches to the `map` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * Also treats functions as functors and will compose them together.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Functor f => (a -> b) -> f a -> f b\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {Array} list The list to be iterated over.\n     * @return {Array} The new list.\n     * @see R.transduce, R.addIndex\n     * @example\n     *\n     *      const double = x => x * 2;\n     *\n     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n     *\n     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n     * @symb R.map(f, [a, b]) = [f(a), f(b)]\n     * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }\n     * @symb R.map(f, functor_o) = functor_o.map(f)\n     */\n\n    var map =\n    /*#__PURE__*/\n    _curry2$1(\n    /*#__PURE__*/\n    _dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {\n      switch (Object.prototype.toString.call(functor)) {\n        case '[object Function]':\n          return curryN(functor.length, function () {\n            return fn.call(this, functor.apply(this, arguments));\n          });\n\n        case '[object Object]':\n          return _reduce(function (acc, key) {\n            acc[key] = fn(functor[key]);\n            return acc;\n          }, {}, keys$1(functor));\n\n        default:\n          return _map(fn, functor);\n      }\n    }));\n\n    /**\n     * Determine if the passed argument is an integer.\n     *\n     * @private\n     * @param {*} n\n     * @category Type\n     * @return {Boolean}\n     */\n    var _isInteger = Number.isInteger || function _isInteger(n) {\n      return n << 0 === n;\n    };\n\n    /**\n     * Returns the nth element of the given list or string. If n is negative the\n     * element at index length + n is returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> a | Undefined\n     * @sig Number -> String -> String\n     * @param {Number} offset\n     * @param {*} list\n     * @return {*}\n     * @example\n     *\n     *      const list = ['foo', 'bar', 'baz', 'quux'];\n     *      R.nth(1, list); //=> 'bar'\n     *      R.nth(-1, list); //=> 'quux'\n     *      R.nth(-99, list); //=> undefined\n     *\n     *      R.nth(2, 'abc'); //=> 'c'\n     *      R.nth(3, 'abc'); //=> ''\n     * @symb R.nth(-1, [a, b, c]) = c\n     * @symb R.nth(0, [a, b, c]) = a\n     * @symb R.nth(1, [a, b, c]) = b\n     */\n\n    var nth =\n    /*#__PURE__*/\n    _curry2$1(function nth(offset, list) {\n      var idx = offset < 0 ? list.length + offset : offset;\n      return _isString(list) ? list.charAt(idx) : list[idx];\n    });\n\n    /**\n     * Retrieves the values at given paths of an object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.27.0\n     * @category Object\n     * @typedefn Idx = [String | Int]\n     * @sig [Idx] -> {a} -> [a | Undefined]\n     * @param {Array} pathsArray The array of paths to be fetched.\n     * @param {Object} obj The object to retrieve the nested properties from.\n     * @return {Array} A list consisting of values at paths specified by \"pathsArray\".\n     * @see R.path\n     * @example\n     *\n     *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]\n     *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]\n     */\n\n    var paths =\n    /*#__PURE__*/\n    _curry2$1(function paths(pathsArray, obj) {\n      return pathsArray.map(function (paths) {\n        var val = obj;\n        var idx = 0;\n        var p;\n\n        while (idx < paths.length) {\n          if (val == null) {\n            return;\n          }\n\n          p = paths[idx];\n          val = _isInteger(p) ? nth(p, val) : val[p];\n          idx += 1;\n        }\n\n        return val;\n      });\n    });\n\n    /**\n     * Retrieve the value at a given path.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @typedefn Idx = String | Int\n     * @sig [Idx] -> {a} -> a | Undefined\n     * @param {Array} path The path to use.\n     * @param {Object} obj The object to retrieve the nested property from.\n     * @return {*} The data at `path`.\n     * @see R.prop, R.nth\n     * @example\n     *\n     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n     *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1\n     *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2\n     */\n\n    var path =\n    /*#__PURE__*/\n    _curry2$1(function path(pathAr, obj) {\n      return paths([pathAr], obj)[0];\n    });\n\n    /**\n     * Returns a function that when supplied an object returns the indicated\n     * property of that object, if it exists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @typedefn Idx = String | Int\n     * @sig Idx -> {s: a} -> a | Undefined\n     * @param {String|Number} p The property name or array index\n     * @param {Object} obj The object to query\n     * @return {*} The value at `obj.p`.\n     * @see R.path, R.nth\n     * @example\n     *\n     *      R.prop('x', {x: 100}); //=> 100\n     *      R.prop('x', {}); //=> undefined\n     *      R.prop(0, [100]); //=> 100\n     *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4\n     */\n\n    var prop =\n    /*#__PURE__*/\n    _curry2$1(function prop(p, obj) {\n      return path([p], obj);\n    });\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the specified\n     * property with the given value. Note that this copies and flattens prototype\n     * properties onto the new object as well. All non-primitive properties are\n     * copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig String -> a -> {k: v} -> {k: v}\n     * @param {String} prop The property name to set\n     * @param {*} val The new value\n     * @param {Object} obj The object to clone\n     * @return {Object} A new object equivalent to the original except for the changed property.\n     * @see R.dissoc, R.pick\n     * @example\n     *\n     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}\n     */\n\n    var assoc =\n    /*#__PURE__*/\n    _curry3$1(function assoc(prop, val, obj) {\n      var result = {};\n\n      for (var p in obj) {\n        result[p] = obj[p];\n      }\n\n      result[prop] = val;\n      return result;\n    });\n\n    /**\n     * Returns a lens for the given getter and setter functions. The getter \"gets\"\n     * the value of the focus; the setter \"sets\" the value of the focus. The setter\n     * should not mutate the data structure.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a\n     * @param {Function} getter\n     * @param {Function} setter\n     * @return {Lens}\n     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      const xLens = R.lens(R.prop('x'), R.assoc('x'));\n     *\n     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n     */\n\n    var lens =\n    /*#__PURE__*/\n    _curry2$1(function lens(getter, setter) {\n      return function (toFunctorFn) {\n        return function (target) {\n          return map(function (focus) {\n            return setter(focus, target);\n          }, toFunctorFn(getter(target)));\n        };\n      };\n    });\n\n    /**\n     * Returns a lens whose focus is the specified property.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig String -> Lens s a\n     * @param {String} k\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      const xLens = R.lensProp('x');\n     *\n     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n     */\n\n    var lensProp =\n    /*#__PURE__*/\n    _curry1$1(function lensProp(k) {\n      return lens(prop(k), assoc(k));\n    });\n\n    var tracker = function (partical) {\r\n        if (typeof partical === 'function') {\r\n            return function (target, key, descriptor) {\r\n                var value = function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var fn = partical.call(this, descriptor.value, this);\r\n                    if (typeof fn === 'function') {\r\n                        //参数为高阶函数\r\n                        return fn.apply(this, args);\r\n                    }\r\n                    else {\r\n                        //普通函数\r\n                        if (typeof fn === 'object') {\r\n                            var data = __assign({}, fn);\r\n                            instance$1.trackEvent(data);\r\n                        }\r\n                        return descriptor.value.apply(this, arguments);\r\n                    }\r\n                };\r\n                // if (descriptor.initializer) {\r\n                //   return propSet('initializer', function() {\r\n                //     const value = descriptor.initializer.apply(this);\r\n                //     return function (...args) {\r\n                //       return partical.call(this, value, this).apply(this, args);\r\n                //     }\r\n                //   }, descriptor);\r\n                // }\r\n                return set_1(lensProp('value'), value, descriptor);\r\n            };\r\n        }\r\n        else if (typeof partical === 'object') {\r\n            return function (target, key, descriptor) {\r\n                var oldValue = descriptor.value;\r\n                descriptor.value = function () {\r\n                    var data = __assign({}, partical);\r\n                    instance$1.trackEvent(data);\r\n                    return oldValue.apply(this, arguments);\r\n                };\r\n                return descriptor;\r\n            };\r\n        }\r\n        else {\r\n            //参数为string 作为tarckId\r\n            return function (target, key, descriptor) {\r\n                var oldValue = descriptor.value;\r\n                descriptor.value = function () {\r\n                    var data = {\r\n                        trackId: partical\r\n                    };\r\n                    instance$1.trackEvent(data);\r\n                    return oldValue.apply(this, arguments);\r\n                };\r\n                return descriptor;\r\n            };\r\n        }\r\n    };\n\n    function _arity$1(n, fn) {\n      /* eslint-disable no-unused-vars */\n      switch (n) {\n        case 0:\n          return function () {\n            return fn.apply(this, arguments);\n          };\n\n        case 1:\n          return function (a0) {\n            return fn.apply(this, arguments);\n          };\n\n        case 2:\n          return function (a0, a1) {\n            return fn.apply(this, arguments);\n          };\n\n        case 3:\n          return function (a0, a1, a2) {\n            return fn.apply(this, arguments);\n          };\n\n        case 4:\n          return function (a0, a1, a2, a3) {\n            return fn.apply(this, arguments);\n          };\n\n        case 5:\n          return function (a0, a1, a2, a3, a4) {\n            return fn.apply(this, arguments);\n          };\n\n        case 6:\n          return function (a0, a1, a2, a3, a4, a5) {\n            return fn.apply(this, arguments);\n          };\n\n        case 7:\n          return function (a0, a1, a2, a3, a4, a5, a6) {\n            return fn.apply(this, arguments);\n          };\n\n        case 8:\n          return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n            return fn.apply(this, arguments);\n          };\n\n        case 9:\n          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n            return fn.apply(this, arguments);\n          };\n\n        case 10:\n          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n            return fn.apply(this, arguments);\n          };\n\n        default:\n          throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n      }\n    }\n\n    var _arity_1 = _arity$1;\n\n    /**\n     * Internal curryN function.\n     *\n     * @private\n     * @category Function\n     * @param {Number} length The arity of the curried function.\n     * @param {Array} received An array of arguments received thus far.\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n\n\n    function _curryN$1(length, received, fn) {\n      return function () {\n        var combined = [];\n        var argsIdx = 0;\n        var left = length;\n        var combinedIdx = 0;\n\n        while (combinedIdx < received.length || argsIdx < arguments.length) {\n          var result;\n\n          if (combinedIdx < received.length && (!_isPlaceholder_1(received[combinedIdx]) || argsIdx >= arguments.length)) {\n            result = received[combinedIdx];\n          } else {\n            result = arguments[argsIdx];\n            argsIdx += 1;\n          }\n\n          combined[combinedIdx] = result;\n\n          if (!_isPlaceholder_1(result)) {\n            left -= 1;\n          }\n\n          combinedIdx += 1;\n        }\n\n        return left <= 0 ? fn.apply(this, combined) : _arity_1(left, _curryN$1(length, combined, fn));\n      };\n    }\n\n    var _curryN_1 = _curryN$1;\n\n    /**\n     * Returns a curried equivalent of the provided function, with the specified\n     * arity. The curried function has two unusual capabilities. First, its\n     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n     * following are equivalent:\n     *\n     *   - `g(1)(2)(3)`\n     *   - `g(1)(2, 3)`\n     *   - `g(1, 2)(3)`\n     *   - `g(1, 2, 3)`\n     *\n     * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n     * \"gaps\", allowing partial application of any combination of arguments,\n     * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n     * the following are equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @func\n     * @memberOf R\n     * @since v0.5.0\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} length The arity for the returned function.\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curry\n     * @example\n     *\n     *      const sumArgs = (...args) => R.sum(args);\n     *\n     *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n     *      const f = curriedAddFourNumbers(1, 2);\n     *      const g = f(3);\n     *      g(4); //=> 10\n     */\n\n\n    var curryN$1 =\n    /*#__PURE__*/\n    _curry2_1(function curryN(length, fn) {\n      if (length === 1) {\n        return _curry1_1(fn);\n      }\n\n      return _arity_1(length, _curryN_1(length, [], fn));\n    });\n\n    var curryN_1 = curryN$1;\n\n    var before = curryN_1(2, function (trackFn, fn) {\r\n        return function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            if (typeof trackFn === 'function') {\r\n                try {\r\n                    var result = trackFn.apply(this, args);\r\n                    if (typeof result === 'object') {\r\n                        instance$1.track(result);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    console.error(e);\r\n                }\r\n            }\r\n            else if (typeof trackFn === 'object') {\r\n                instance$1.track(trackFn);\r\n            }\r\n            else if (typeof trackFn === 'string') {\r\n                var data = {\r\n                    trackId: trackFn\r\n                };\r\n                instance$1.track(data);\r\n            }\r\n            var evalF = function () {\r\n                var _this = this;\r\n                setTimeout(function () {\r\n                    fn.apply(_this, args);\r\n                }, 300);\r\n            };\r\n            return evalF.apply(this);\r\n        };\r\n    });\r\n    var after = curryN_1(2, function (trackFn, fn) {\r\n        return function () {\r\n            var _this = this;\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            var r = fn.apply(this, args);\r\n            var evalF = function () {\r\n                if (typeof trackFn === 'function') {\r\n                    try {\r\n                        var result = trackFn.apply(_this, args);\r\n                        if (typeof result === 'object') {\r\n                            instance$1.track(result);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n                else if (typeof trackFn === 'object') {\r\n                    instance$1.track(trackFn);\r\n                }\r\n                else if (typeof trackFn === 'string') {\r\n                    var data = {\r\n                        trackId: trackFn\r\n                    };\r\n                    instance$1.track(data);\r\n                }\r\n            };\r\n            if (isThenable(r)) {\r\n                return r.then(function (rr) {\r\n                    evalF();\r\n                    return rr;\r\n                });\r\n            }\r\n            evalF();\r\n            return r;\r\n        };\r\n    });\n\n    var generate = function (type) {\r\n        var watch = [];\r\n        var track = {\r\n            bind: function (el, binding, vnode) {\r\n                var index = watch.findIndex(function (element) { return element === el; });\r\n                var isWatched = index !== -1;\r\n                if (el.style.display === 'none') {\r\n                    if (!isWatched)\r\n                        watch.push(el);\r\n                    return;\r\n                }\r\n                else {\r\n                    if (isWatched)\r\n                        watch.splice(index, 1);\r\n                }\r\n                if (!isWatched && (notChanged(binding) || isEmpty(binding)))\r\n                    return;\r\n                var info = {};\r\n                if (typeof binding.value === 'object') {\r\n                    info = binding.value;\r\n                    //if (value.pageURL) args.push(value.pageURL)\r\n                }\r\n                else if (typeof binding.value === 'string' && binding.value) {\r\n                    info.trackId = binding.value;\r\n                }\r\n                if (type === 'PAGE') {\r\n                    instance$1.trackPage(info);\r\n                }\r\n                else {\r\n                    instance$1.trackView(el, info);\r\n                }\r\n            },\r\n            unbind: function (el, binding) {\r\n                var index = watch.findIndex(function (element) { return element === el; });\r\n                if (index !== -1)\r\n                    watch.splice(index, 1);\r\n                instance.end();\r\n            },\r\n            update: function (el, binding, vnode) { }\r\n        };\r\n        track.update = track.bind;\r\n        return track;\r\n    };\n\n    var trackView = generate('VIEW');\n\n    function trackEvent (el, binding) {\r\n        if (notChanged(binding) || isEmpty(binding)) {\r\n            return;\r\n        }\r\n        var info = {};\r\n        if (typeof binding.value === 'object' && binding.value) {\r\n            info = binding.value;\r\n        }\r\n        else if (typeof binding.value === 'string') {\r\n            info.trackId = binding.value;\r\n        }\r\n        else if (typeof binding.value === 'number') {\r\n            info.trackId = binding.value + '';\r\n        }\r\n        el._trackerInfo = info;\r\n        el._isWatchTrack = true; //去除自动点击埋点\r\n        var events = Object.keys(binding.modifiers).filter(function (modifier) {\r\n            return binding.modifiers[modifier];\r\n        });\r\n        if (!events.length)\r\n            events.push('click');\r\n        events.forEach(function (event) {\r\n            el.removeEventListener(event, handleEvent, false);\r\n            el.addEventListener(event, handleEvent, false);\r\n        });\r\n    }\r\n    function handleEvent(e) {\r\n        this._trackerInfo.eventName = e.type.toUpperCase();\r\n        if (this.tagName === 'A' && this.href) {\r\n            instance$1.trackLink(this, this._trackerInfo);\r\n        }\r\n        else {\r\n            instance$1.trackDom(this, this._trackerInfo);\r\n        }\r\n    }\n\n    var trackPage = generate('PAGE');\n\n    function hijackHistoryEvent () {\r\n        if (getFlag('historyInjected'))\r\n            return;\r\n        function historyEventTrigger(event, data) {\r\n            var fetchEvent = new CustomEvent(event, { detail: data });\r\n            window.dispatchEvent(fetchEvent);\r\n        }\r\n        function spellUrl(oldURL, newURL) {\r\n            if (/:\\/\\//.test(newURL)) {\r\n                return newURL;\r\n            }\r\n            var host = oldURL.match(/^.*:\\/\\/[^/]+/)[0];\r\n            return host + (/^\\//.test(newURL) ? '' : '/') + newURL;\r\n        }\r\n        var globalData = {\r\n            url: getLocationHref()\r\n        };\r\n        var oldOnpopstate = window.onpopstate;\r\n        window.onpopstate = function () {\r\n            var data = {\r\n                newURL: window.location.href,\r\n                oldURL: globalData.url\r\n            };\r\n            globalData.url = window.location.href;\r\n            historyEventTrigger.apply(this, ['historyPopstate', data]);\r\n            if (oldOnpopstate) {\r\n                return oldOnpopstate.apply(this, arguments);\r\n            }\r\n        };\r\n        var oldPushState = window.history.pushState;\r\n        oldPushState &&\r\n            (window.history.pushState = function (state, title, url) {\r\n                var data = {\r\n                    newURL: spellUrl(globalData.url, url),\r\n                    oldURL: globalData.url\r\n                };\r\n                globalData = {\r\n                    url: data.newURL\r\n                };\r\n                historyEventTrigger.apply(this, ['historyPushState', data]);\r\n                if (oldPushState) {\r\n                    return oldPushState.apply(this, arguments);\r\n                }\r\n            });\r\n        setFlag('historyInjected', true);\r\n    }\n\n    function routeChange() {\r\n        instance.change();\r\n    }\r\n    var install = function (conf) {\r\n        if (getFlag('install'))\r\n            return;\r\n        setFlag('install');\r\n        if (conf) {\r\n            setConfig(conf);\r\n        }\r\n        var config = getConfig();\r\n        //注入history事件\r\n        hijackHistoryEvent();\r\n        //自动埋页面\r\n        if (config.autoTrackPage) {\r\n            instance$1.trackPage();\r\n        }\r\n        // if (config.performance) {\r\n        //   actionTracker.trackPerformance();\r\n        // }\r\n        // 页面时间start\r\n        // if (config.pageTime && !pageTimeTracker.info.trackId) {\r\n        //   pageTimeTracker.start();\r\n        // }\r\n        // 单页面应用routerchange\r\n        if (config.watchHistoryAndHash) {\r\n            if (typeof window.onpopstate === 'undefined') {\r\n                window.addEventListener('hashchange', routeChange);\r\n            }\r\n            window.addEventListener('historyPushState', routeChange);\r\n            window.addEventListener('historyPopstate', routeChange);\r\n        }\r\n        // onbeforeunload 和 onunload 都触发发送\r\n        var onLeave = (function () {\r\n            var sended = false;\r\n            return function () {\r\n                if (sended) {\r\n                    return;\r\n                }\r\n                if (config.pageTime) {\r\n                    instance.end();\r\n                }\r\n                sendAsync();\r\n                sended = true;\r\n            };\r\n        })();\r\n        window.addEventListener('beforeunload', onLeave);\r\n        window.addEventListener('unload', onLeave);\r\n        document.addEventListener('click', function (e) {\r\n            var path = e.path;\r\n            var element = e.target;\r\n            if (typeof e.path === 'undefined' || !e.isTrusted) {\r\n                return;\r\n            }\r\n            for (var _i = 0, _a = e.path; _i < _a.length; _i++) {\r\n                var target = _a[_i];\r\n                if (target.tagName === 'BODY') {\r\n                    break;\r\n                }\r\n                //是否有埋点属性\r\n                if (target.getAttribute('data-track') ||\r\n                    (config.autoTrackClick &&\r\n                        (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') &&\r\n                        !target._isWatchTrack)) {\r\n                    if (element.tagName === 'A' && element.href) {\r\n                        //劫持a链接注入本页面的code\r\n                        var pageId = getPageInfo().pageId;\r\n                        if (typeof pageId === 'string') {\r\n                            if (/\\?.*=/.test(element.href)) {\r\n                                element.href = element.href.replace(/\\?/, \"?referrer-id=\" + pageId + \"&\");\r\n                            }\r\n                            else if (/\\?/.test(element.href) === false) {\r\n                                element.href += \"?referrer-id=\" + pageId;\r\n                            }\r\n                            else {\r\n                                element.href = element.href.replace(/\\?/, \"?referrer-id=\" + pageId);\r\n                            }\r\n                        }\r\n                        instance$1.trackLink(target);\r\n                    }\r\n                    else {\r\n                        instance$1.trackDom(target);\r\n                    }\r\n                }\r\n            }\r\n        }, false);\r\n    };\r\n    //自动install\r\n    window.addEventListener('load', function () {\r\n        var config = getConfig();\r\n        if (config.autoInstall) {\r\n            install();\r\n        }\r\n    });\n\n    var trackDom = instance$1.trackDom;\r\n    var trackPage$1 = instance$1.trackPage;\r\n    var trackEvent$1 = instance$1.trackEvent;\r\n    var trackView$1 = instance$1.trackView;\r\n    var trackLink = instance$1.trackLink;\r\n    var track = instance$1.track;\n\n    if (typeof XMLHttpRequest === 'undefined') {\r\n        throw new Error('tracker requires ie10+');\r\n    }\r\n    try {\r\n        \"production\";\r\n    }\r\n    catch (e) {\r\n        var g = typeof window !== 'undefined' ? window : global;\r\n        if (typeof g.process === 'undefined')\r\n            g.process = {};\r\n        g.process.env = {};\r\n    }\r\n    if (typeof _TrackerGlobalData === 'undefined') {\r\n        window._TrackerGlobalData = {};\r\n    }\n\n    exports.actionTracker = instance$1;\n    exports.after = after;\n    exports.before = before;\n    exports.getConfig = getConfig;\n    exports.install = install;\n    exports.login = login;\n    exports.logout = logout;\n    exports.send = send;\n    exports.sendAsync = sendAsync;\n    exports.sendSync = sendSync;\n    exports.setConfig = setConfig;\n    exports.timeTracker = instance;\n    exports.track = track;\n    exports.trackDom = trackDom;\n    exports.trackEvent = trackEvent$1;\n    exports.trackLink = trackLink;\n    exports.trackPage = trackPage$1;\n    exports.trackView = trackView$1;\n    exports.tracker = tracker;\n    exports.vTrackEvent = trackEvent;\n    exports.vTrackPage = trackPage;\n    exports.vTrackView = trackView;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=telescope.min.js.map\n","import { tracker, after, before } from '../../dist/telescope.min';\n\nclass OneClass {\n  constructor() {\n    this.qqq = 'wode';\n  }\n\n  @tracker('fn1')\n  fn1() {\n    console.log('fn1', this);\n  }\n  @tracker({ trackId: 'fn2Id' })\n  fn2() {\n    console.log('fn2', this);\n  }\n  @tracker(function () {\n    console.log(this);\n    return { trackId: 'fn3Id' };\n  })\n  fn3() {\n    console.log('fn3', this);\n  }\n\n  @tracker(\n    after(function () {\n      console.log(this);\n      console.log('fn4 after');\n      return { trackId: 'fn4Id' };\n    })\n  )\n  fn4() {\n    console.log('fn4');\n  }\n\n  @tracker(\n    before(function () {\n      console.log('fn5 before', this);\n      return { trackId: 'fn5Id' };\n    })\n  )\n  fn5() {\n    console.log(this);\n    console.log('fn5');\n  }\n\n  @tracker(\n    after(() => {\n      console.log('fn6 after');\n      return { trackId: 'fn6Id' };\n    })\n  )\n  fn6() {\n    return new Promise((resolve, reject) => {\n      console.log('fn6');\n      setTimeout(() => {\n        resolve();\n      }, 1000);\n    });\n  }\n\n  @tracker(after('fn7Id'))\n  fn7() {\n    console.log('fn7');\n  }\n\n  @tracker(after('fn8Id'))\n  fn8() {\n    console.log('fn8');\n  }\n}\n\nwindow.test = new OneClass();\n"],"names":["OneClass","tracker","trackId","console","log","after","before","qqq","Promise","resolve","reject","setTimeout","window","test"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;;;;;;;;;;;;;EA6BO,MAAI,QAAQ,GAAG,YAAW;EAC7B,IAAA,QAAQ,GAAG,MAAM,CAAC,MAAP,IAAiB,SAAS,QAAT,CAAkB,CAAlB,EAAqB;EAC7C,WAAK,IAAI,CAAJ,EAAO,CAAC,GAAG,CAAX,EAAc,CAAC,GAAG,SAAS,CAAC,MAAjC,EAAyC,CAAC,GAAG,CAA7C,EAAgD,CAAC,EAAjD,EAAqD;EACjD,QAAA,CAAC,GAAG,SAAS,CAAC,CAAD,CAAb;;EACA,aAAK,IAAI,CAAT,IAAc,CAAd,EAAiB,IAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,CAArC,EAAwC,CAAxC,CAAJ,EAAgD,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAR;EACpE;;EACD,aAAO,CAAP;EACR,KANI;;EAOA,WAAO,QAAQ,CAAC,KAAT,CAAe,IAAf,EAAqB,SAArB,CAAP;EACH,GATM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC3BDA,mBAKHC,eAAO,CAAC,KAAD,WAIPA,eAAO,CAAC;EAAEC,EAAAA,OAAO,EAAE;EAAX,CAAD,WAIPD,eAAO,CAAC,YAAY;EACnBE,EAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;EACA,SAAO;EAAEF,IAAAA,OAAO,EAAE;EAAX,GAAP;EACD,CAHO,WAQPD,eAAO,CACNI,eAAK,CAAC,YAAY;EAChBF,EAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;EACAD,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;EACA,SAAO;EAAEF,IAAAA,OAAO,EAAE;EAAX,GAAP;EACD,CAJI,CADC,WAWPD,eAAO,CACNK,eAAM,CAAC,YAAY;EACjBH,EAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0B,IAA1B;EACA,SAAO;EAAEF,IAAAA,OAAO,EAAE;EAAX,GAAP;EACD,CAHK,CADA,WAWPD,eAAO,CACNI,eAAK,CAAC,YAAM;EACVF,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;EACA,SAAO;EAAEF,IAAAA,OAAO,EAAE;EAAX,GAAP;EACD,CAHI,CADC,WAePD,eAAO,CAACI,eAAK,CAAC,OAAD,CAAN,WAKPJ,eAAO,CAACI,eAAK,CAAC,OAAD,CAAN;EA9DR,sBAAc;EAAA;;EACZ,SAAKE,GAAL,GAAW,MAAX;EACD;;;;4BAGK;EACJJ,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmB,IAAnB;EACD;;;4BAEK;EACJD,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmB,IAAnB;EACD;;;4BAKK;EACJD,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmB,IAAnB;EACD;;;4BASK;EACJD,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;EACD;;;4BAQK;EACJD,MAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;EACAD,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;EACD;;;4BAQK;EACJ,aAAO,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;EACtCP,QAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;EACAO,QAAAA,UAAU,CAAC,YAAM;EACfF,UAAAA,OAAO;EACR,SAFS,EAEP,IAFO,CAAV;EAGD,OALM,CAAP;EAMD;;;4BAGK;EACJN,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;EACD;;;4BAGK;EACJD,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;EACD;;;;;EAGHQ,MAAM,CAACC,IAAP,GAAc,IAAIb,QAAJ,EAAd;;;;"}